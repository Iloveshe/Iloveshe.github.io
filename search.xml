<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2023/10/05/%E6%88%91%E7%9A%84%E9%9D%A2%E7%BB%8F/"/>
      <url>/2023/10/05/%E6%88%91%E7%9A%84%E9%9D%A2%E7%BB%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="我的面经"><a href="#我的面经" class="headerlink" title="我的面经"></a>我的面经</h1><h3 id="1-TCP-IP-OSI七层"><a href="#1-TCP-IP-OSI七层" class="headerlink" title="1.TCP&#x2F;IP &#x2F;OSI七层"></a>1.TCP&#x2F;IP &#x2F;OSI七层</h3><p>TCP&#x2F;IP和OSI是两种不同的网络协议体系结构，用于描述和定义计算机网络中的通信协议和层次结构。</p><ol><li><p>OSI七层模型（Open Systems Interconnection）：OSI模型是国际标准化组织（ISO）提出的一种网络协议体系结构，将计算机网络通信划分为七个层次，每个层次负责不同的功能和任务。这些层次从底层到顶层分别是：</p><ul><li>物理层（Physical Layer）：负责传输比特流，处理物理介质、电压等物理特性。</li><li>数据链路层（Data Link Layer）：提供可靠的点对点数据传输，将比特流划分为帧并进行错误检测和纠正。</li><li>网络层（Network Layer）：处理数据包的路由和转发，实现不同网络之间的互联。</li><li>传输层（Transport Layer）：提供端到端的可靠数据传输和错误恢复，通常使用TCP或UDP协议。</li><li>会话层（Session Layer）：建立、管理和终止应用程序之间的会话。</li><li>表示层（Presentation Layer）：数据格式的转换和表示，加密和解密数据等。</li><li>应用层（Application Layer）：提供用户应用程序访问网络的接口，如HTTP、FTP、SMTP等。</li></ul></li><li><p>TCP&#x2F;IP模型（Transmission Control Protocol&#x2F;Internet Protocol）：TCP&#x2F;IP是实际应用最广泛的网络协议体系结构，也是互联网所采用的标准协议。它并没有像OSI模型那样严格划分为七个层次，而是将功能划分为四个层次，从底层到顶层分别是：</p><ul><li>网络接口层（Network Interface Layer）：负责物理设备、网络接口和数据链路层的通信。</li><li>网络层（Internet Layer）：处理数据包的路由和转发，负责寻址和分组传输。</li><li>传输层（Transport Layer）：提供端到端的可靠数据传输和错误恢复，通常使用TCP或UDP协议。</li><li>应用层（Application Layer）：提供用户应用程序访问网络的接口，如HTTP、FTP、SMTP等。</li></ul></li></ol><p>相对于OSI模型而言，TCP&#x2F;IP模型将会话层、表示层和物理层的功能整合到了更高层的应用层中，并且更加贴近实际应用。TCP&#x2F;IP模型是互联网通信的基础，而OSI模型则更多地用于理论研究和教学。</p><h3 id="2-c-11的新特性"><a href="#2-c-11的新特性" class="headerlink" title="2.c++11的新特性"></a>2.c++11的新特性</h3><p>C++11引入了许多新的语言特性和库，以下是一些C++11的新特性的简要介绍：</p><h4 id="2-1自动类型推断（auto）"><a href="#2-1自动类型推断（auto）" class="headerlink" title="2.1自动类型推断（auto）"></a>2.1<strong>自动类型推断（auto）</strong></h4><p>**引入了关键字<code>auto</code>**，允许编译器根据初始化表达式的类型推断变量的类型。</p><h4 id="2-2统一的初始化语法（-语法）："><a href="#2-2统一的初始化语法（-语法）：" class="headerlink" title="2.2统一的初始化语法（{}&#96;语法）："></a>2.2<strong>统一的初始化语法（{}&#96;语法）：</strong></h4><p><strong>使用<code>&#123;&#125;</code>语法进行初始化</strong>，可以用于初始化各种类型的对象，包括数组、结构体、类等。</p><p>在 C++11 中，引入了统一的初始化语法，也就是大括号 <code>&#123;&#125;</code> 初始化语法。这种语法可以用来初始化各种类型的变量，包括基本类型、数组、结构体、类等。下面是一些例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a&#123;<span class="number">1</span>&#125;; <span class="comment">// 初始化基本类型</span></span><br><span class="line"><span class="type">int</span> b[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// 初始化数组</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; c&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// 初始化容器</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;<span class="type">int</span> x; <span class="type">int</span> y;&#125;;</span><br><span class="line">Point d&#123;<span class="number">1</span>, <span class="number">2</span>&#125;; <span class="comment">// 初始化结构体</span></span><br></pre></td></tr></table></figure><p>这种初始化语法可以避免一些类型转换的问题，例如下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">x</span><span class="params">(<span class="number">5.3</span>)</span></span>; <span class="comment">// x 被初始化为 5，有精度损失</span></span><br><span class="line"><span class="type">int</span> y&#123;<span class="number">5.3</span>&#125;; <span class="comment">// 编译错误，无法从 double 转换为 int</span></span><br></pre></td></tr></table></figure><p>使用 <code>&#123;&#125;</code> 初始化语法时，如果发生了精度损失或者类型转换不安全，编译器会报错。</p><h4 id="2-3范围基于的for循环（for-char-c-s-）"><a href="#2-3范围基于的for循环（for-char-c-s-）" class="headerlink" title="2.3范围基于的for循环（for(char c:s)）"></a>2.3<strong>范围基于的<code>for</code>循环（for(char c:s)）</strong></h4><p>用于遍历容器或范围内的元素，可以方便地遍历数组、容器和其他支持迭代器的对象。</p><h4 id="2-4nullptr关键字："><a href="#2-4nullptr关键字：" class="headerlink" title="2.4nullptr关键字："></a>2.4<code>nullptr</code>关键字：</h4><p><strong>用于表示空指针，</strong>避免了使用<code>NULL</code>或<code>0</code>可能引发的二义性问题。</p><h4 id="2-5强类型枚举（不能混用）："><a href="#2-5强类型枚举（不能混用）：" class="headerlink" title="2.5强类型枚举（不能混用）："></a>2.5<strong>强类型枚举（不能混用）：</strong></h4><p>**引入了<code>enum class</code>**关键字，提供了一种更强类型和更安全的枚举类型。不同类型的枚举值之间，或者枚举值和整数之间，都不能直接进行比较。</p><p>在没有强类型枚举的语言中，常见的错误包括：</p><ol><li><p><strong>无意识地进行错误的比较</strong>：假设你有两个不同的枚举类型，如 <code>enum Color &#123; RED, GREEN, BLUE &#125;;</code> 和 <code>enum Fruit &#123; APPLE, BANANA, ORANGE &#125;;</code>。在这种情况下，你可能无意识地写出了 <code>if (RED == APPLE)</code> 这样的代码。虽然这在语义上明显是错误的，但在编译器看来，它是合法的，因为它们都是整数。这可能导致难以追踪的运行时错误。</p></li><li><p><strong>枚举值的隐式类型转换</strong>：传统的枚举类型在某些情况下会被隐式地转换为整数，这可能导致意外的行为。例如，你可能尝试将枚举值传递给期望整数参数的函数，而没有意识到这会导致枚举值被转换为整数。</p></li><li><p><strong>命名空间污染</strong>：传统的枚举值都位于全局命名空间，这可能导致命名冲突。例如，如果你有两个不同的枚举类型，它们都有一个名为 <code>RED</code> 的值，那么你将无法在同一作用域中使用它们。</p></li></ol><p>通过引入强类型枚举，C++11 有效地解决了这些问题，提高了类型安全性。</p><h4 id="2-6移动语义"><a href="#2-6移动语义" class="headerlink" title="2.6移动语义"></a>2.6移动语义</h4><p>引入了右值引用和移动构造函数、移动赋值运算符，提供了高效的资源转移和避免不必要的拷贝操作。</p><h4 id="2-7Lambda表达式"><a href="#2-7Lambda表达式" class="headerlink" title="2.7Lambda表达式"></a>2.7<strong>Lambda表达式</strong></h4><p><strong>允许在代码中内联定义匿名函数</strong>，在需要调用函数的地方直接定义函数，简化了函数对象的编写和使用。</p><p>它可以让你定义一个匿名函数，并可以捕获一些变量进行操作。Lambda 表达式的</p><h5 id="2-7-1一般形式如下："><a href="#2-7-1一般形式如下：" class="headerlink" title="2.7.1一般形式如下："></a>2.7.1一般形式如下：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture](parameters) -&gt; <span class="keyword">return</span>-type &#123;body&#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>capture</code> 是捕获列表，定义了在 Lambda 表达式中可以访问的外部变量。</li><li><code>parameters</code> 是参数列表，就像在普通函数中一样。</li><li><code>return-type</code> 是返回类型，如果省略，编译器会自动推导出返回类型。</li><li><code>body</code> 是函数体，包含了 Lambda 表达式要执行的代码。</li></ul><p>下面给出一个 Lambda 表达式的示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// lambda expression to check even numbers</span></span><br><span class="line">    <span class="keyword">auto</span> check_even = [](<span class="type">int</span> n) &#123; <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">0</span>; &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : v) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check_even</span>(i)) &#123;</span><br><span class="line">            std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; is even.\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// lambda expression to compute sum</span></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    std::for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [&amp;sum](<span class="type">int</span> n) &#123; sum += n; &#125;);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum is &quot;</span> &lt;&lt; sum &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们定义了两个 Lambda 表达式。第一个表达式 <code>check_even</code> 接受一个整数作为参数，检查这个整数是否为偶数。第二个表达式是在 <code>std::for_each</code> 算法中使用的，它使用捕获列表 <code>[&amp;sum]</code> 来捕获外部的 <code>sum</code> 变量，并在函数体中对 <code>sum</code> 进行累加操作。</p><h5 id="2-7-2匿名函数（lambda）与内联函数"><a href="#2-7-2匿名函数（lambda）与内联函数" class="headerlink" title="2.7.2匿名函数（lambda）与内联函数"></a>2.7.2匿名函数（lambda）与内联函数</h5><ol><li><p>匿名函数：<br>匿名函数也常常被称为 Lambda 函数，是在 C++11 中引入的。这是一种在需要函数的地方定义函数的技术，不需要提前在类或命名空间中声明。匿名函数常常在算法中作为参数传递。例如：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; vec &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;  <span class="comment">// Sort in descending order</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在这个例子中，我们传递了一个匿名函数（也叫做 Lambda 表达式）给 <code>std::sort</code> 函数。这个匿名函数接受两个参数 <code>a</code> 和 <code>b</code>，并返回 <code>a &gt; b</code>，这样 <code>std::sort</code> 就会按照降序进行排序。</p></li><li><p>内联函数：<br>内联函数是一种优化技术，用于减少函数调用的开销。当你声明一个函数为内联时，编译器会尝试在调用该函数的地方<strong>插入函数的实体</strong>，而不是通过常规的函数调用机制（即保存寄存器、设置参数、跳转到函数代码、然后再跳回来）。</p><p>声明内联函数的关键字是 <code>inline</code>，例如：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明函数为内联并不意味着函数一定会被内联，这仅仅是一个对编译器的建议。实际上，编译器可能会忽略这个建议，尤其是对于复杂的或递归的函数。</p><p>使用内联函数需要谨慎。虽然内联函数可以减少函数调用的开销，但过度使用内联函数可能会导致代码膨胀，因为同样的函数代码会被插入到多个调用的地方。这可能会导致更多的缓存不命中，从而减慢程序的速度。</p></li></ol><h5 id="2-7-3匿名函数的优点和适用场合："><a href="#2-7-3匿名函数的优点和适用场合：" class="headerlink" title="2.7.3匿名函数的优点和适用场合："></a>2.7.3匿名函数的优点和适用场合：</h5><p>匿名函数（Lambda函数）有一些特点使得它们在某些场合特别有用。</p><h6 id="简洁性"><a href="#简洁性" class="headerlink" title="简洁性"></a><strong>简洁性</strong></h6><ul><li>匿名函数使代码更加简洁、易读，无需定义额外的、可能只会使用一次的小函数。</li></ul><h6 id="局部性"><a href="#局部性" class="headerlink" title="局部性"></a><strong>局部性</strong></h6><ul><li>匿名函数可以直接使用定义它的作用域中的变量，这可以避免额外的参数传递或状态管理。</li></ul><h6 id="实时性"><a href="#实时性" class="headerlink" title="实时性"></a><strong>实时性</strong></h6><ul><li>可以在需要的地方及时定义和使用，不需要提前在类或命名空间中声明。</li></ul><p>匿名函数在很多场合下都非常有用，比如：</p><h6 id="作参数"><a href="#作参数" class="headerlink" title="作参数"></a>作参数</h6><ul><li>作为其他函数或算法的参数，如 <code>std::sort</code>, <code>std::find_if</code>等。</li></ul><h6 id="小函数"><a href="#小函数" class="headerlink" title="小函数"></a>小函数</h6><ul><li><p>用在需要小函数但又不想为此写一个单独的函数的地方，如在 GUI 编程中用于响应事件。</p></li><li><p>用在需要可调用对象，但不想写完整的函数或类的地方，例如，线程函数或者回调函数。</p></li><li><p>在C++中，”可调用对象”是一个泛化的概念，它不仅包括普通函数，还包括函数对象（functor）和lambda表达式。对于一些场景，我们可能只需要一次性使用的、简单的行为，这时就不需要定义完整的函数或者类。</p><p>例如，你可能在一个线程中需要执行一个简单的任务。这个任务可能只是一小段代码，并且只在这个地方使用。如果为了这个任务去写一个完整的函数或者类可能显得过于繁琐。这时，你可以使用一个lambda表达式（匿名函数）直接定义这个行为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">([]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">// 在这里执行一些操作</span></span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们创建了一个新的线程，这个线程执行的操作就是lambda表达式中定义的那些代码。这里的lambda表达式就是一个”可调用对象”。</p><p>相似的，对于某些回调函数的场景，比如某个API需要一个回调函数来处理某个事件。如果这个事件处理很简单，只在这个地方使用，也可以直接使用lambda表达式，而不必写一个完整的函数或者类。</p></li></ul><ol><li><p>为什么内联函数可能会导致更多的缓存不命中：</p><p>CPU 缓存通常比内存要快得多，因此如果可以直接从缓存中获取数据，程序的执行速度就会更快。如果同一个函数被多次内联到不同的地方，那么这些函数的代码就可能会占用更多的缓存空间。这可能会导致其他的数据或代码被挤出缓存，从而增加从内存中获取数据的次数，即“缓存不命中”。</p><p>例如，如果一个内联函数被反复调用，那么它的多个拷贝可能会占据缓存中的大部分空间。这可能会导致其他代码或数据被挤出缓存，从而减慢程序的运行速度。</p><p>这是为什么过度使用内联函数可能会导致性能下降的原因。在实际编程中，应适度使用内联函数，特别是在那些频繁调用的小函数中。</p></li></ol><h4 id="2-8线程支持库（）"><a href="#2-8线程支持库（）" class="headerlink" title="2.8线程支持库（）"></a>2.8<strong>线程支持库</strong>（）</h4><p>引入了<code>std::thread</code>等类，支持多线程编程，包括线程创建、同步、互斥等功能。</p><h4 id="2-9并发支持库（）"><a href="#2-9并发支持库（）" class="headerlink" title="2.9并发支持库（）"></a>2.9并发支持库（）</h4><p>引入了原子操作、互斥量、条件变量等并发编程的工具，支持更安全和高效的并发操作。</p><h4 id="2-11智能指针（）"><a href="#2-11智能指针（）" class="headerlink" title="2.11智能指针（）"></a>2.11<strong>智能指针（）</strong></h4><p>：引入了<code>std::shared_ptr</code>和<code>std::unique_ptr</code>等智能指针类型，提供了更安全和方便的内存管理机制。</p><h4 id="2-12字符串字面量（）"><a href="#2-12字符串字面量（）" class="headerlink" title="2.12字符串字面量（）"></a>2.12字符串字面量（）</h4><p>：引入了原生字符串字面量（<code>R&quot;(...)&quot;</code>）和用户自定义的字符串字面量。</p><p>这只是C++11中一些主要的新特性，还有其他更多的特性和改进。C++11的引入丰富了C++语言的功能和表达能力，提供了更方便、更高效的编程工具和库。</p><h4 id="2-13尾置返回类型"><a href="#2-13尾置返回类型" class="headerlink" title="2.13尾置返回类型"></a>2.13尾置返回类型</h4><p>我在之前的回答中提到的 C++11 的尾置返回类型和 <code>auto</code> 关键字，其实是与函数返回类型的推断相关的特性，而不是函数重载。尾置返回类型允许你<strong>在函数参数列表之后声明函数的返回类型。这在某些情况下非常有用，例如当函数的返回类型依赖于函数的参数类型时</strong>。例如：</p><h5 id="2-13-1-decltype-t-u"><a href="#2-13-1-decltype-t-u" class="headerlink" title="2.13.1-&gt; decltype(t + u)"></a>2.13.1-&gt; decltype(t + u)</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T t, U u)</span> -&gt; <span class="title">decltype</span><span class="params">(t + u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>decltype(t + u)</code> 是尾置返回类型，它使得函数的返回类型能够依赖于参数 <code>t</code> 和 <code>u</code> 的类型。<code>auto</code> 关键字告诉编译器去自动推断 <code>add</code> 函数的返回类型。</p><p>再次对之前的错误表示歉意，并感谢你的耐心。</p><h4 id="2-13NULL二义性问题"><a href="#2-13NULL二义性问题" class="headerlink" title="2.13NULL二义性问题"></a>2.13NULL二义性问题</h4><p>在早期的C++标准中，<code>NULL</code>通常用于表示空指针，它实际上是一个宏定义，被定义为整数0。然而，由于0在C++中也可以用于表示整数常量，因此使用<code>NULL</code>可能会导致一些二义性问题。</p><p>例如，考虑以下情况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">void</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，我们调用函数<code>foo</code>并传递了<code>NULL</code>作为参数。然而，由于<code>NULL</code>被定义为整数0，这会导致函数重载的二义性，编译器无法确定应该调用哪个函数。因为<code>foo(int)</code>和<code>foo(void*)</code>都可以匹配参数为0的调用。</p><p>为了解决这个问题，C++11引入了<code>nullptr</code>关键字。<code>nullptr</code>表示空指针，它是一个特殊的关键字，不会引发二义性问题。我们可以将上述示例中的<code>NULL</code>替换为<code>nullptr</code>，代码将变为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">void</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">foo</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下，编译器将能够准确地确定调用<code>foo(void*)</code>，因为<code>nullptr</code>表示空指针类型，不会引发与整数0的二义性。这样，使用<code>nullptr</code>可以避免因为使用<code>NULL</code>或<code>0</code>而导致的函数重载二义性问题。</p><h4 id="2-14智能指针种类"><a href="#2-14智能指针种类" class="headerlink" title="2.14智能指针种类"></a>2.14智能指针种类</h4><p>C++11引入了三种主要的智能指针类型，它们是：</p><h5 id="2-2-1std-unique-ptr"><a href="#2-2-1std-unique-ptr" class="headerlink" title="2.2.1std::unique_ptr"></a>2.2.1std::unique_ptr</h5><ol><li><code>std::unique_ptr</code>：独占指针，提供独立所有权的所有权模型。它是一个轻量级的智能指针，不允许多个<code>unique_ptr</code>同时管理同一个对象，因此可以避免悬空指针和内存泄漏的问题。<code>unique_ptr</code>在所有权转移时使用移动语义，因此能够实现高效的资源管理。</li></ol><h5 id="2-2-2std-shared-ptr"><a href="#2-2-2std-shared-ptr" class="headerlink" title="2.2.2std::shared_ptr"></a>2.2.2std::shared_ptr</h5><ol><li><code>std::shared_ptr</code>：共享指针，提供共享所有权的所有权模型。多个<code>shared_ptr</code>可以同时管理同一个对象，引用计数机制会追踪对象的引用数量，当最后一个<code>shared_ptr</code>销毁时，会自动释放对象的内存。<code>shared_ptr</code>可以避免资源的提前释放和内存泄漏问题，但可能存在循环引用导致的内存泄漏。</li></ol><h5 id="2-2-3std-weak-ptr"><a href="#2-2-3std-weak-ptr" class="headerlink" title="2.2.3std::weak_ptr"></a>2.2.3std::weak_ptr</h5><ol><li><code>std::weak_ptr</code>：弱引用指针，用于解决<code>shared_ptr</code>的循环引用问题。<code>weak_ptr</code>可以共享对象的引用，但<strong>不会增加对象的引用计数</strong>。它通常用于辅助<code>shared_ptr</code>，允许检查所管理的对象是否还存在。<code>weak_ptr</code>可以通过<code>lock()</code>方法获得一个有效的<code>shared_ptr</code>，如果对象已被销毁，则返回一个空的<code>shared_ptr</code>。</li></ol><p>这些智能指针类型定义在头文件 <code>&lt;memory&gt;</code> 中，并位于 <code>std</code> 命名空间中。它们提供了更安全、更方便的内存管理机制，能够自动释放资源，避免内存泄漏和悬空指针等问题。正确使用智能指针可以提高代码的可靠性和可维护性。</p><h5 id="2-2-4weak-ptr破解shared-ptr的循环引用问题"><a href="#2-2-4weak-ptr破解shared-ptr的循环引用问题" class="headerlink" title="2.2.4weak_ptr破解shared_ptr的循环引用问题"></a>2.2.4weak_ptr破解shared_ptr的循环引用问题</h5><p>循环引用指的是两个或多个对象相互持有对方的<code>shared_ptr</code>，导致对象之间形成了一个环状的引用关系。这种情况下，由于<code>shared_ptr</code>使用引用计数来追踪对象的引用数量，即使外部不再使用这些对象，其引用计数也不会降为零，从而导致内存泄漏。</p><p>让我们通过一个示例来说明循环引用的问题。考虑以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    shared_ptr&lt;Node&gt; next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createCircularReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    shared_ptr&lt;Node&gt; node1 = <span class="built_in">make_shared</span>&lt;Node&gt;();</span><br><span class="line">    shared_ptr&lt;Node&gt; node2 = <span class="built_in">make_shared</span>&lt;Node&gt;();</span><br><span class="line"></span><br><span class="line">    node1-&gt;next = node2;</span><br><span class="line">    node2-&gt;next = node1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">createCircularReference</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，我们定义了一个<code>Node</code>类，每个节点包含一个指向下一个节点的<code>shared_ptr</code>。在<code>createCircularReference</code>函数中，我们创建了两个节点<code>node1</code>和<code>node2</code>，并将它们的<code>next</code>指针相互设置为对方，形成了循环引用。</p><p>当<code>createCircularReference</code>函数执行完毕后，<code>node1</code>和<code>node2</code>的引用计数仍然为2，因为它们相互引用。由于引用计数不为零，<code>shared_ptr</code>不会自动释放内存，从而导致内存泄漏。</p><p>为了解决循环引用导致的内存泄漏问题，可以使用<code>weak_ptr</code>来打破循环引用。<code>weak_ptr</code>是一种不增加引用计数的智能指针，它可以从<code>shared_ptr</code>构造，但不会增加对象的引用计数。我们可以将<code>next</code>成员变量改为<code>weak_ptr</code>，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    weak_ptr&lt;Node&gt; next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过使用<code>weak_ptr</code>，循环引用中的对象不再相互增加引用计数，当不再有<code>shared_ptr</code>指向它们时，对象的引用计数会降为零，从而正确地释放内存。当需要访问对象时，可以通过调用<code>lock()</code>方法获取一个有效的<code>shared_ptr</code>，在保证对象存在的前提下使用它。</p><p>总结起来，循环引用是指两个或多个对象相互持有对方的<code>shared_ptr</code>，导致对象之间形成了一个环状的引用关系。如果使用<code>shared_ptr</code>来管理这样的循环引用，可能会导致内存泄漏。通过使用<code>weak_ptr</code>来打破循环引用，可以解决这个问题。</p><h3 id="3-线程之间通信的手段"><a href="#3-线程之间通信的手段" class="headerlink" title="3.线程之间通信的手段"></a>3.线程之间通信的手段</h3><p>在线程之间进行通信时，有多种手段可供选择，下面列举了几种常用的线程间通信的方法：</p><h4 id="3-1共享内存"><a href="#3-1共享内存" class="headerlink" title="3.1共享内存"></a>3.1共享内存</h4><ol><li>共享内存（Shared Memory）：多个线程可以通过共享内存区域来传递数据。线程可以直接读写共享内存，通过对共享内存的互斥访问来同步数据访问。</li></ol><h4 id="3-2管道（Pipe）"><a href="#3-2管道（Pipe）" class="headerlink" title="3.2管道（Pipe）"></a>3.2管道（Pipe）</h4><ol><li>管道（Pipe）：管道是一种半双工的通信机制，其中一个线程将数据写入管道，另一个线程从管道读取数据。管道可以用于有限数据量的线程间通信。</li></ol><h4 id="3-3消息队列（Message-Queue）"><a href="#3-3消息队列（Message-Queue）" class="headerlink" title="3.3消息队列（Message Queue）"></a>3.3消息队列（Message Queue）</h4><ol><li>消息队列（Message Queue）：消息队列提供了一种异步的线程间通信机制。线程可以将消息发送到队列中，其他线程可以从队列中接收并处理这些消息。</li></ol><h4 id="3-4事件（Event）"><a href="#3-4事件（Event）" class="headerlink" title="3.4事件（Event）"></a>3.4事件（Event）</h4><ol><li>事件（Event）：事件用于线程之间的通知机制。一个线程可以等待一个事件的发生，而其他线程可以触发该事件来通知等待的线程。</li></ol><p>以上是一些常用的线程间通信手段，每种方法都适用于不同的场景和需求。选择适当的线程间通信方法取决于具体的应用需求和线程之间的交互模式。</p><h3 id="4-makefile"><a href="#4-makefile" class="headerlink" title="4.makefile"></a>4.makefile</h3><p>一个 Makefile 文件主要包括四个部分：</p><ol><li><p><strong>变量定义</strong>：在这个部分，我们定义一些常用的变量，例如编译器，编译选项，源文件，对象文件，目标程序等。</p></li><li><p><strong>目标规则</strong>：这个部分定义了如何从源文件生成目标程序。每个目标规则包括一个或多个目标，一些依赖和一些命令。命令通常包括编译命令和链接命令。</p></li><li><p><strong>伪目标</strong>：这部分定义了一些不代表实际文件的目标，例如 <code>clean</code>。这些目标通常用于执行一些特殊的任务，例如清理编译生成的文件。</p></li><li><p><strong>变量和函数</strong>：在 Makefile 中，我们可以定义自己的变量和函数，或者使用 Makefile 提供的内置变量和函数。我们也可以使用条件判断和循环等控制结构。</p></li></ol><p>下面是一个基本的 Makefile 文件的示例：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 变量定义</span></span><br><span class="line">CC = gcc</span><br><span class="line">CFLAGS = -Wall -g</span><br><span class="line">SRCS = main.c foo.c bar.c</span><br><span class="line">OBJS = $(SRCS:.c=.o)</span><br><span class="line">TARGET = prog</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标规则</span></span><br><span class="line"><span class="variable">$(TARGET)</span>: <span class="variable">$(OBJS)</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -o <span class="variable">$(TARGET)</span> <span class="variable">$(OBJS)</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o: %.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 伪目标</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f <span class="variable">$(OBJS)</span> <span class="variable">$(TARGET)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 内置变量和函数</span></span><br><span class="line"><span class="section">debug:</span></span><br><span class="line">    @echo <span class="string">&quot;SRCS = <span class="variable">$(SRCS)</span>&quot;</span></span><br><span class="line">    @echo <span class="string">&quot;OBJS = <span class="variable">$(OBJS)</span>&quot;</span></span><br></pre></td></tr></table></figure><p>在这个例子中，我们定义了一些常用的变量，例如 <code>CC</code>，<code>CFLAGS</code>，<code>SRCS</code>，<code>OBJS</code>，<code>TARGET</code>。我们也定义了如何从 <code>.c</code> 文件生成 <code>.o</code> 文件，以及如何从 <code>.o</code> 文件生成目标程序。我们还定义了一个 <code>clean</code> 伪目标来清理编译生成的文件。最后，我们定义了一个 <code>debug</code> 目标来打印一些变量的值，帮助我们调试 Makefile。</p><h3 id="5-cmake"><a href="#5-cmake" class="headerlink" title="5.cmake"></a>5.cmake</h3><p>一个cmakelist.txt文件的大体架构是什么样的</p><p>CMake是一个开源的跨平台自动化建构系统，用来管理软件构建过程，并且可以生成标准的构建文件（如 Unix 的 Makefile 或者 Windows 的 Visual Studio 工程文件）。CMake使用名为 <code>CMakeLists.txt</code> 的文件来描述构建过程。</p><p>以下是一个基本的 <code>CMakeLists.txt</code> 文件的框架：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置CMake最低版本要求</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置项目名称</span></span><br><span class="line"><span class="keyword">project</span>(MyProject)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置变量</span></span><br><span class="line"><span class="keyword">set</span>(SOURCE_FILES main.cpp foo.cpp bar.cpp)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置编译器选项</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS <span class="string">&quot;$&#123;CMAKE_CXX_FLAGS&#125; -std=c++14&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加可执行文件</span></span><br><span class="line"><span class="keyword">add_executable</span>(MyProject <span class="variable">$&#123;SOURCE_FILES&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果项目中有库文件，可以使用下面的命令来链接</span></span><br><span class="line"><span class="comment"># target_link_libraries(MyProject MyLibrary)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果项目中有头文件需要包含，可以使用下面的命令来添加头文件路径</span></span><br><span class="line"><span class="comment"># include_directories(/path/to/headers)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果需要添加子目录，可以使用下面的命令</span></span><br><span class="line"><span class="comment"># add_subdirectory(subdir)</span></span><br></pre></td></tr></table></figure><p>上述CMakeLists.txt文件做了以下事情：</p><ol><li>定义了所需要的CMake的最低版本。</li><li>定义了一个项目，并给项目起名为 <code>MyProject</code>。</li><li>设置了一个变量 <code>SOURCE_FILES</code>，包含了所有需要编译的源文件。</li><li>设置了编译选项，这里是设置了C++的标准为C++14。</li><li>添加了一个可执行文件 <code>MyProject</code>，并指定了编译需要的源文件。</li><li>注释中提供了如何链接库文件，添加头文件路径，以及添加子目录的示例。</li></ol><p>当然，这只是最基础的CMakeLists.txt文件，实际项目中的CMakeLists.txt文件可能会包含更多的设置和命令。</p><h3 id="1-epoll技术"><a href="#1-epoll技术" class="headerlink" title="1.epoll技术"></a>1.epoll技术</h3><p>Epoll是Linux系统下的一种高效的I&#x2F;O多路复用技术，相比于传统的select和poll，epoll可以提供更高的性能。下面是epoll的主要特点和使用方法。</p><h4 id="1-1Epoll的特点："><a href="#1-1Epoll的特点：" class="headerlink" title="1.1Epoll的特点："></a><strong>1.1Epoll的特点：</strong></h4><h5 id="1-1-1无需遍历："><a href="#1-1-1无需遍历：" class="headerlink" title="1.1.1无需遍历："></a>1.1.1<strong>无需遍历：</strong></h5><p>对于select和poll，每次调用都需要遍历整个文件描述符集，复杂度为O(n)。而epoll使用一个事件驱动的方式，只对那些真正活跃的文件描述符进行操作，因此不需要遍历整个文件描述符集，这使得epoll在处理大量文件描述符时能够提供更高的性能。</p><h5 id="1-1-2不限制最大并发连接："><a href="#1-1-2不限制最大并发连接：" class="headerlink" title="1.1.2不限制最大并发连接："></a>1.1.2<strong>不限制最大并发连接：</strong></h5><p>select和poll的最大并发连接数受限于进程打开文件描述符的数量，而epoll并没有这个限制。</p><h6 id="原因：epoll内核红黑树"><a href="#原因：epoll内核红黑树" class="headerlink" title="原因：epoll内核红黑树"></a>原因：epoll内核红黑树</h6><p>，select、poll用户空间数组</p><p>实际上，epoll的并发连接数也是有限制的，这个限制通常由系统内存的大小决定。当我们说epoll没有文件描述符数量的限制时，我们是在比较它与select和poll。</p><p>在select和poll中，文件描述符是保存在用户空间的一个数组中，这个数组在每次调用select或poll时都需要从用户空间复制到内核空间，这导致了两个问题。一是用户空间的数组大小有限，不能无限大，因此文件描述符数量受到限制。二是每次调用select或poll都需要复制文件描述符数组，这在文件描述符数量很大时会造成很大的开销。</p><p>而epoll则完全不同。在epoll中，文件描述符和对应的事件是保存在内核空间的一个红黑树中，而且只在添加或删除文件描述符时才需要修改这个红黑树。因此，epoll不需要在每次调用时复制文件描述符，也没有因为用户空间数组大小限制而限制文件描述符的数量。但是，由于文件描述符和事件是保存在内核空间的，因此它们的数量是受到系统内存大小限制的。</p><p>总的来说，虽然epoll的并发连接数也是有限的，但是这个限制通常要大于select和poll，并且在处理大量并发连接时，epoll的效率也要高于select和poll。</p><h5 id="1-1-3事件驱动："><a href="#1-1-3事件驱动：" class="headerlink" title="1.1.3事件驱动："></a>1.1.3<strong>事件驱动：</strong></h5><p>epoll使用事件驱动的方式，当注册的文件描述符准备好读写操作时，epoll会通知用户进程。</p><h4 id="1-2Epoll和select对比"><a href="#1-2Epoll和select对比" class="headerlink" title="1.2Epoll和select对比"></a>1.2Epoll和select对比</h4><h5 id="1-2-1-epoll内核保存一份fd集合-红黑树"><a href="#1-2-1-epoll内核保存一份fd集合-红黑树" class="headerlink" title="1.2.1.epoll内核保存一份fd集合(红黑树)"></a>1.2.1.epoll内核保存一份fd集合(红黑树)</h5><p>，<strong>select每次调用都要拷贝到内核</strong>。select 调用需要传入 fd 数组，需要拷贝一份到内核，高并发场景下这样的拷贝消耗的资源是惊人的。</p><p>内核中保存一份文件描述符集合，无需用户每次都重新传入，只需告诉内核修改的部分即可。</p><p>epoll的事件注册是持久的</p><h5 id="1-2-2epoll异步事件唤醒，而不是轮询"><a href="#1-2-2epoll异步事件唤醒，而不是轮询" class="headerlink" title="1.2.2epoll异步事件唤醒，而不是轮询"></a>1.2.2epoll异步事件唤醒，而不是轮询</h5><p>内核不再通过轮询的方式找到就绪的文件描述符，而是通过异步 IO 事件唤醒。</p><p>select 在内核层仍然是通过遍历的方式检查文件描述符的就绪状态，是个同步过程，只不过无系统调用切换上下文的开销。（内核层可优化为异步事件通知）</p><h5 id="1-2-3epoll仅仅返回IO事件的fd"><a href="#1-2-3epoll仅仅返回IO事件的fd" class="headerlink" title="1.2.3epoll仅仅返回IO事件的fd"></a>1.2.3epoll仅仅返回IO事件的fd</h5><p>内核仅会将有 IO 事件的文件描述符返回给用户，用户也无需遍历整个文件描述符集合。</p><p>select 仅仅返回可读文件描述符的个数，具体哪个可读还是要用户自己遍历。（可优化为只返回给用户就绪的文件描述符，无需用户做无效的遍历）</p><h4 id="1-3Epoll的使用方法："><a href="#1-3Epoll的使用方法：" class="headerlink" title="1.3Epoll的使用方法："></a><strong>1.3Epoll的使用方法：</strong></h4><h5 id="1-3-1创建一个epoll实例-create："><a href="#1-3-1创建一个epoll实例-create：" class="headerlink" title="1.3.1创建一个epoll实例+create："></a>1.3.1<strong>创建一个epoll实例+create：</strong></h5><p>使用<code>epoll_create</code>函数创建一个epoll实例，该函数返回一个文件描述符，表示epoll实例。</p><h5 id="1-3-2添加-修改-删除事件-ctl："><a href="#1-3-2添加-修改-删除事件-ctl：" class="headerlink" title="1.3.2添加&#x2F;修改&#x2F;删除事件+ctl："></a>1.3.2<strong>添加&#x2F;修改&#x2F;删除事件+ctl：</strong></h5><p>然后，应用程序可以对这个 epoll 文件描述符调用 <code>epoll_ctl</code> 函数，注册一组文件描述符，并指定感兴趣的事件，例如可读、可写、连接关闭等。使用<code>epoll_ctl</code>函数来添加、修改或删除需要监控的文件描述符以及对应的事件。事件类型可以是<code>EPOLLIN</code>（可读）、<code>EPOLLOUT</code>（可写）、连接关闭等。</p><h5 id="1-3-3等待事件-wait："><a href="#1-3-3等待事件-wait：" class="headerlink" title="1.3.3等待事件+wait："></a>1.3.3<strong>等待事件+wait：</strong></h5><p> 使用<code>epoll_wait</code>函数等待事件的发生。等待注册的文件描述符上发生的事件。这个函数会阻塞，直到有事件发生或者超时。一旦有事件发生，<code>epoll_wait</code> 就会返回，并将发生的事件填充到应用程序提供的数组中。当一个或多个文件描述符准备好读写操作时，<code>epoll_wait</code>函数返回，并通过参数返回准备好的文件描述符和对应的事件。</p><h5 id="1-3-4处理事件："><a href="#1-3-4处理事件：" class="headerlink" title="1.3.4处理事件："></a>1.3.4<strong>处理事件：</strong></h5><p> 根据<code>epoll_wait</code>函数返回的文件描述符和事件，用户进程进行相应的读写操作。例如，如果一个文件描述符上有数据可读，那么应用程序就可以进行读操作。</p><p>使用epoll需要注意，epoll仅适用于Linux系统，不同的系统可能需要使用不同的I&#x2F;O多路复用技术，如FreeBSD&#x2F;OS X通常使用kqueue，Windows使用IOCP等。</p><h3 id="2-socket技术的流程"><a href="#2-socket技术的流程" class="headerlink" title="2.socket技术的流程"></a>2.socket技术的流程</h3><p> Socket的流程主要分为三个步骤：</p><h4 id="2-1创建socket；"><a href="#2-1创建socket；" class="headerlink" title="2.1创建socket；"></a>2.1创建socket；</h4><p>服务器端和客户端分别创建socket</p><h4 id="2-2-s绑定-监听；"><a href="#2-2-s绑定-监听；" class="headerlink" title="2.2 s绑定,监听；"></a>2.2 s绑定,监听；</h4><p>服务器端绑定IP地址和端口号，然后开始监听</p><h4 id="2-3c连接请求，s接受连接；"><a href="#2-3c连接请求，s接受连接；" class="headerlink" title="2.3c连接请求，s接受连接；"></a>2.3c连接请求，s接受连接；</h4><p>客户端向服务器发起连接请求，服务器接受连接</p><h4 id="2-4read和write函数进行数据通信。"><a href="#2-4read和write函数进行数据通信。" class="headerlink" title="2.4read和write函数进行数据通信。"></a>2.4read和write函数进行数据通信。</h4><p>然后客户端和服务器端可以通过read和write函数进行数据通信。</p><h3 id="3-TCP-UDP在Socket中的不同"><a href="#3-TCP-UDP在Socket中的不同" class="headerlink" title="3.TCP&#x2F;UDP在Socket中的不同"></a>3.<strong>TCP&#x2F;UDP在Socket中的不同</strong></h3><h4 id="3-1TCP面型连接、可靠，UDP相反"><a href="#3-1TCP面型连接、可靠，UDP相反" class="headerlink" title="3.1TCP面型连接、可靠，UDP相反"></a>3.1TCP面型连接、可靠，UDP相反</h4><p>TCP是面向连接的可靠协议，它提供了数据的完整性和顺序保证。UDP是无连接的不可靠协议，它不保证数据的完整性和顺序。在Socket编程中，这两种协议主要的区别在于TCP需要先建立连接然后才能通信，而UDP不需要建立连接就可以直接发送数据。</p><h3 id="4-多态"><a href="#4-多态" class="headerlink" title="4.多态"></a>4.<em>多态</em></h3><p>多态是面向对象编程的一个重要特性，它允许使用父类类型的指针或引用来操作子类对象。多态可以分为静态多态和动态多态。</p><h4 id="4-1静态多态"><a href="#4-1静态多态" class="headerlink" title="4.1静态多态"></a>4.1静态多态</h4><p>是通过函数重载（编译器阶段）和模板实现</p><h5 id="4-1-1函数重载"><a href="#4-1-1函数重载" class="headerlink" title="4.1.1函数重载"></a>4.1.1函数重载</h5><p>函数重载是指在同一作用域内可以定义名字相同而参数列表不同的几个函数。调用这样的函数时，编译器会根据提供的实参类型和数量决定调用哪个函数。这就是函数重载。</p><h4 id="4-2动态多态"><a href="#4-2动态多态" class="headerlink" title="4.2动态多态"></a>4.2动态多态</h4><p>运行时多态，是通过虚函数实现的。</p><h5 id="4-2-1虚函数，实现（虚函数表）："><a href="#4-2-1虚函数，实现（虚函数表）：" class="headerlink" title="4.2.1虚函数，实现（虚函数表）："></a>4.2.1<strong>虚函数，实现（虚函数表）：</strong></h5><p>虚函数是实现动态多态的一种机制，它允许子类重新定义父类的虚函数。虚函数的实现主要依赖于虚函数表（vtable），每个有虚函数的类都有一个对应的虚函数表，表中存储了虚函数的地址。当调用对象的虚函数时，编译器会根据对象的实际类型去虚函数表中查找对应的函数地址，然后调用。</p><ol><li><strong>C++11新特性，了解多少说多少：</strong> 回答这个问题需要根据你实际了解的C++11新特性来进行，比如上面已经提到的自动类型推导，nullptr，智能指针，基于范围的for循环，lambda表达式，右值引用和移动语义，初始化列表，多线程支持等</li></ol><h3 id="5-Vector的底层实现原理"><a href="#5-Vector的底层实现原理" class="headerlink" title="5.Vector的底层实现原理"></a>5.<strong>Vector的底层实现原理</strong></h3><p> Vector是一种动态数组，其底层通常是通过连续的内存空间来实现的。当向vector中添加元素时，如果当前的内存空间不足以容纳新的元素，vector会重新分配一块更大的内存空间，然后将原来的元素复制到新的内存空间。</p><p><code>std::vector</code>是C++ STL (标准模板库)中的一种数据结构，它提供了动态数组的功能。</p><p><code>std::vector</code> 的底层实现原理基本如下：</p><ol><li><p><strong>动态数组</strong>：<code>std::vector</code> 使用动态数组来存储其元素。这意味着，当你添加新元素时，如果当前分配的内存不足以存放新元素，<code>std::vector</code> 将申请一块新的更大的内存区域，将现有的元素复制到新的内存区域，然后释放旧的内存区域。这种操作在添加新元素时会导致一些额外的开销，但由于<code>std::vector</code>通常会以2的倍数扩大内存空间，因此这种开销在大多数情况下是可以接受的。</p></li><li><p><strong>连续内存</strong>：与其他一些数据结构（如<code>std::list</code>和<code>std::deque</code>）不同，<code>std::vector</code> 在内存中存储的元素是连续的。这意味着你可以通过指针和迭代器直接访问内存，也可以利用 CPU 缓存的空间局部性原理提高性能。</p></li><li><p><strong>元素访问</strong>：<code>std::vector</code> 提供了多种访问其元素的方法，包括通过索引、通过迭代器以及通过 <code>front()</code> 和 <code>back()</code> 函数来访问第一个和最后一个元素。</p></li><li><p><strong>内存管理</strong>：<code>std::vector</code> 使用RAII (资源获取即初始化)机制来管理其内存。这意味着当<code>std::vector</code>对象被销毁时，其使用的内存将自动被释放，避免了内存泄露。</p></li><li><p><strong>灵活性</strong>：<code>std::vector</code> 提供了大量的方法来操作其元素，包括添加和删除元素、搜索元素、排序元素等等。这使得<code>std::vector</code>成为C++中非常灵活和实用的数据结构。</p></li><li><p><strong>模板化</strong>：就像其他 STL 容器一样，<code>std::vector</code> 是模板化的，这意味着你可以用任何数据类型创建一个<code>std::vector</code>，只要该数据类型支持拷贝或者移动语义。</p></li></ol><p>这就是 <code>std::vector</code> 的底层实现原理。虽然具体的实现可能会因不同的编译器和 STL 版本而略有不同，但大体上应该是这样的。</p><h3 id="6-递归实现反转链表"><a href="#6-递归实现反转链表" class="headerlink" title="6.递归实现反转链表"></a>6.<em>递归实现反转链表</em></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">   <span class="type">int</span> val;</span><br><span class="line">   ListNode *next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> head;</span><br><span class="line">   &#125;</span><br><span class="line">   ListNode* newHead = <span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">   head-&gt;next-&gt;next = head;</span><br><span class="line">   head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">   <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个递归函数的工作原理是先反转后面的链表，然后将当前节点设置为其后继节点的后继，然后返回新的头节点。</p><h4 id="6-1递归解题的思路"><a href="#6-1递归解题的思路" class="headerlink" title="6.1递归解题的思路"></a>6.1递归解题的思路</h4><p>你的理解是正确的，这其实就是递归思想的精髓之一：“假设递归函数已经写好”，这也叫做假设法或者归纳法。它是一个解决递归问题的关键步骤。</p><p>在设计递归函数的时候，我们通常会进行以下步骤：</p><ol><li><p><strong>确定递归函数的参数和返回值</strong>：参数就是传入什么数据给函数，返回值就是函数要完成的目标。</p></li><li><p><strong>确定终止条件</strong>：也就是什么时候不用再递归下去，可以直接返回结果。</p></li><li><p><strong>确定函数的等价关系式</strong>：也就是找到<strong>问题规模更小的，但是和原问题具有相同结构的子问题</strong>。然后假设递归函数已经能够正确处理这个子问题，用递归函数来表示出这个等价关系式。</p></li></ol><p>例如，我们要写一个递归函数求解阶乘，那么我们可以这么考虑：</p><ol><li><p><strong>确定递归函数的参数和返回值</strong>：参数就是我们要求解阶乘的数n，返回值就是n的阶乘。</p></li><li><p><strong>确定终止条件</strong>：如果n为1，那么1的阶乘就是1，这就是我们的终止条件。</p></li><li><p><strong>确定函数的等价关系式</strong>：我们可以知道n的阶乘等于n乘以n-1的阶乘，所以等价关系式就是f(n) &#x3D; n * f(n - 1)。</p></li></ol><p>然后我们就可以编写出阶乘的递归函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n * <span class="built_in">factorial</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以你的理解是非常准确的，递归问题的关键在于“假设递归函数已经写好”，然后找出函数的等价关系式，同时不要忘记终止条件。</p><h3 id="7-服务器端远程编码的经历"><a href="#7-服务器端远程编码的经历" class="headerlink" title="7.服务器端远程编码的经历"></a>7.服务器端远程编码的经历</h3><p>是的，这就是一种形式的服务器端远程编码。在你的例子中，虚拟机充当服务器，而你在Windows主机上的VS Code就像是客户端。当你在VS Code中写代码并保存时，代码实际上是保存在远程的虚拟机（服务器）上。然后，你可以在远程服务器上编译和运行这些代码。</p><p>在这种设置中，VS Code 通过 SSH 协议与远程服务器进行通信。你可能使用的是 VS Code 的 “Remote - SSH” 扩展或类似的工具，这些工具能够使 VS Code 能够通过 SSH 连接到远程服务器，并在那里打开文件、编辑文件、运行命令等。</p><p>所以，虽然你在本地的 VS Code 中进行编程，但实际的代码文件、编译和运行过程都是在远程服务器上进行的，这就是一种形式的 “服务器端远程编码”。</p><p>为了配置 SSH 远程登录，你需要在本地机器（即客户端）和远程服务器之间建立一个安全的 SSH 连接。这通常需要以下步骤：</p><ol><li><p><strong>安装 SSH</strong>：确保你的本地机器和远程服务器都已经安装了 SSH。对于 Linux 和 macOS，SSH 通常会预先安装。对于 Windows，你可能需要额外安装一个 SSH 客户端，例如 PuTTY 或者使用内置的 OpenSSH 客户端。</p></li><li><p><strong>生成 SSH 密钥对</strong>：在你的本地机器上生成一个 SSH 密钥对。密钥对包括一个公钥和一个私钥。你可以使用 <code>ssh-keygen</code> 命令来生成密钥对。例如，<code>ssh-keygen -t rsa -b 4096</code> 将生成一个 RSA 类型的密钥对，密钥长度为 4096 位。</p></li><li><p><strong>将公钥上传到远程服务器</strong>：你需要将你的公钥上传到远程服务器的 <code>~/.ssh/authorized_keys</code> 文件中。你可以使用 <code>ssh-copy-id</code> 命令来自动完成这个步骤，例如，<code>ssh-copy-id username@remote_host</code>。</p></li><li><p><strong>测试 SSH 连接</strong>：你现在应该能够使用 SSH 连接到远程服务器了。试一试 <code>ssh username@remote_host</code>，看看是否能够成功登录。在你第一次连接到新的远程服务器时，SSH 会提示你验证服务器的指纹信息。确认无误后，SSH 会将服务器的指纹信息保存在 <code>~/.ssh/known_hosts</code> 文件中，以后的连接将不会再提示。</p></li><li><p><strong>VSCode 远程开发设置</strong>：安装 VSCode 的 “Remote - SSH” 插件，然后按 <code>F1</code> 打开命令输入框，输入 “Remote-SSH: Connect to Host…” 命令，然后选择你的远程主机即可。你可能需要提供你的 SSH 登录凭证（例如，私钥的位置）。</p></li></ol><p>这就是 SSH 远程登录的基本步骤。请注意，这些步骤可能会根据你的具体环境和需求有所不同。</p><h3 id="8-事件驱动编程"><a href="#8-事件驱动编程" class="headerlink" title="8.事件驱动编程"></a>8.事件驱动编程</h3><p>事件驱动编程是一种编程范式，它的核心思想是程序的执行流程由外部事件来驱动。在这种模型中，应用程序是由事件驱动的，如用户输入、系统状态改变、网络消息等。</p><p>在网络编程中，事件驱动模型可以高效地处理大量的并发连接。具体来说，事件驱动的服务器并不会为每个连接创建一个线程或进程，而是将所有的连接注册到事件通知机制（例如epoll）上，然后在一个循环中等待事件的发生。当某个连接上有数据到来或者可以进行写操作时，事件通知机制就会通知服务器，服务器就可以进行相应的读或写操作。</p><p>事件驱动模型的优点在于它可以处理大量的并发连接，而且不需要为每个连接创建一个线程或进程，这样可以大大降低系统的资源消耗。另外，事件驱动模型由于是响应式的，所以可以很好地适应不均匀的负载。</p><p>但是，事件驱动模型也有它的缺点。首先，编程复杂度比较高，因为需要处理各种事件和状态。其次，事件驱动模型通常需要使用非阻塞I&#x2F;O，这样在处理某个事件时，如果数据没有准备好，就需要返回并处理其他事件，然后再回来继续处理这个事件，这会使得程序的逻辑变得复杂。</p><p>总的来说，事件驱动模型是一种高效处理大量并发连接的编程模型，但是编程复杂度也相对较高。</p><h3 id="9-竞态条件"><a href="#9-竞态条件" class="headerlink" title="9.竞态条件"></a>9.竞态条件</h3><ol><li><p><strong>什么是竞态条件（Race Condition）？如何避免竞态条件？</strong></p><p>竞态条件是指多个线程访问和修改同一数据，而最终结果取决于线程的调度顺序。竞态条件通常会导致数据错乱。可以通过同步机制（例如加锁）来避免竞态条件。</p></li></ol><h3 id="10-结构体内存对齐"><a href="#10-结构体内存对齐" class="headerlink" title="10.结构体内存对齐"></a>10.结构体内存对齐</h3><p>内存对齐是计算机硬件层面的一个特性，是因为硬件访问对齐内存的数据会更有效率。它对应的在编程语言中的概念，如 C 和 C++ 中的结构体内存对齐，也是为了提升访问效率。</p><p>结构体内存对齐的规则由编译器决定，并遵循以下原则：</p><ol><li><p><strong>结构体变量的首地址对齐规则</strong>：结构体变量的首地址是其最宽基本类型成员大小的整数倍。假设结构体中最大的数据类型为int，其大小为4字节，那么该结构体的首地址必须为4的倍数。</p></li><li><p><strong>结构体每个成员对应相对偏移量的对齐规则</strong>：结构体的每个成员相对于结构体首地址的偏移量（offset）都是该成员的类型大小的整数倍。如若成员类型为int，大小为4字节，那么该成员的偏移量应为4的倍数。</p></li><li><p><strong>结构体的总大小</strong>：结构体的总大小为结构体最宽基本类型成员大小的整数倍。若成员中最宽的为double类型，大小为8字节，那么结构体的总大小应为8的倍数。如果不是，编译器会在最后一个成员后面填充字节。</p></li></ol><p>下面是一个例子说明这种规则：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">S</span> &#123;</span><br><span class="line">    <span class="type">char</span> a;    <span class="comment">// 1 byte, 偏移量0</span></span><br><span class="line">    <span class="type">int</span> b;     <span class="comment">// 4 bytes, 偏移量4 (需要在 &#x27;a&#x27; 后面填充3个字节)</span></span><br><span class="line">    <span class="type">short</span> c;   <span class="comment">// 2 bytes, 偏移量8</span></span><br><span class="line">    <span class="comment">// 编译器可能会在 &#x27;c&#x27; 后面填充2个字节，以确保整个结构体的大小为最宽元素(即 &#x27;int&#x27;)大小的倍数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里的S结构体实际大小为12字节。其中 ‘a’ 占用1字节，’b’ 占用4字节，’c’ 占用2字节，然后在 ‘a’ 后面填充了3个字节，’c’ 后面填充了2个字节，使得整个结构体的大小为4的倍数。</p><p>请注意，不同的编译器可能会有不同的对齐规则，以上规则适用于大多数编译器，但并非所有。此外，许多编译器允许程序员通过特定的编译器指令（如GCC的 <code>__attribute__((packed))</code> ）来修改默认的对齐规则。</p><h3 id="11-编译cgi"><a href="#11-编译cgi" class="headerlink" title="11.编译cgi"></a>11.编译cgi</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o output.cgi input.cpp</span><br></pre></td></tr></table></figure><h3 id="12-编译知识"><a href="#12-编译知识" class="headerlink" title="12.编译知识"></a>12.编译知识</h3><p>编译器是一种计算机程序，它可以将一种编程语言（源代码）转化为另一种编程语言（通常是机器语言）。编译过程主要分为以下几个阶段：</p><ol><li><p><strong>词法分析（Lexical Analysis）</strong>：词法分析器会将源代码分割成一系列的词素（token）。每个词素都是源代码中的最小有意义的单位，比如关键字、标识符、运算符、分隔符等。</p></li><li><p><strong>语法分析（Syntax Analysis）</strong>：语法分析器会根据词法分析的结果，按照预定的语法规则进行解析，形成一颗抽象语法树（AST）。如果源代码中存在语法错误，这个阶段就会报错。</p></li><li><p><strong>语义分析（Semantic Analysis）</strong>：在这个阶段，编译器会检查源代码的语义，比如变量是否已经声明、函数调用的参数是否匹配等。如果源代码中存在语义错误，这个阶段也会报错。</p></li><li><p><strong>中间代码生成（Intermediate Code Generation）</strong>：在语义分析之后，编译器会生成一种中间代码，这种代码通常是独立于具体机器的，便于进行进一步的优化。</p></li><li><p><strong>代码优化（Code Optimization）</strong>：编译器会对中间代码进行各种优化，以提高目标代码的运行效率。这些优化可能包括消除冗余的计算、简化复杂的运算、重新排列语句顺序等。</p></li><li><p><strong>目标代码生成（Code Generation）</strong>：最后，编译器会将优化后的中间代码转化为目标机器语言。这个过程可能涉及到寄存器分配、指令选择等问题。</p></li></ol><p>这只是编译过程的基础概述。实际上，编译器的设计和实现还涉及到许多复杂的技术和算法，比如符号表管理、错误恢复、依赖性分析等。这也是计算机科学中的一个重要研究领域。</p><h3 id="13-命名实体识别"><a href="#13-命名实体识别" class="headerlink" title="13.命名实体识别"></a>13.命名实体识别</h3><p>当然，我会更详细地解读这段代码的每个模块。</p><ol><li><p>数据预处理模块</p><ul><li><p><code>build_corpus</code>函数：这个函数用于从文件中读取数据，并将数据整理成合适的格式。对于训练集、验证集和测试集，它都会执行这个过程。这个函数首先初始化几个空列表来存储单词和标签，然后按行读取文件。每读取一行，就把这一行的单词和标签添加到对应的列表中。最后，这个函数返回包含所有单词和标签的列表，以及训练集、验证集和测试集。</p></li><li><p><code>build_map</code>函数：这个函数用于创建两个字典，一个是word2id，它把每个单词映射到一个唯一的ID，另一个是tag2id，它把每个标签映射到一个唯一的ID。这两个字典在后续的模型训练中会被用到，因为模型无法直接处理文本数据，需要把文本数据转化为数字。</p></li></ul></li><li><p>模型定义模块</p><ul><li><p><code>Mymodel</code>类：这个类定义了一个基于双向LSTM和CRF的命名实体识别模型。在这个类的<code>__init__</code>方法中，定义了模型的各个层，包括一个嵌入层用于把单词转化为向量，一个双向LSTM层用于把单词向量序列转化为隐藏状态序列，一个线性层用于把隐藏状态序列转化为标签得分序列，以及一个CRF层用于计算最终的标签序列。在<code>forward</code>方法中，定义了模型的前向传播过程。在<code>test</code>方法中，用Viterbi算法对标签序列进行解码。</p></li><li><p><code>cal_lstm_crf_loss</code>函数：这个函数用于计算损失，是模型训练过程中的关键。它首先计算了gold_score，即正确标签序列的得分，然后计算了total_score，即所有可能的标签序列的得分。损失就是total_score和gold_score的差值。</p></li></ul></li><li><p>数据集构建模块</p><ul><li><code>MyDataset</code>类：这是一个继承自torch.utils.data.Dataset的类，定义了一个数据集。在<code>__init__</code>方法中，它接受数据，并把数据转化为适合模型输入的形式。在<code>__getitem__</code>方法中，它返回一个数据样本，这个样本包括单词序列和对应的标签序列。在<code>__len__</code>方法中，它返回数据集的大小。</li></ul></li><li><p>模型训练与测试模块</p><p>这部分代码位于主函数中。首先，它调用了前面定义的数据预处理函数，读取数据</p></li></ol><p>抱歉，我遇到了一些问题无法打开之前的代码链接。但根据我对这段代码的理解，我可以继续详细解读模型训练与测试模块。</p><ol start="4"><li><p>模型训练与测试模块</p><ul><li><p>训练循环：在主函数中，首先通过数据预处理函数读取数据，并构建数据集和数据加载器。然后定义模型，优化器和损失函数。接下来是训练循环，对于每一个epoch，都会对每一个batch的数据进行前向传播，计算损失，进行反向传播，更新模型参数。在每个epoch结束时，都会对验证集进行评估，计算验证集的性能。</p></li><li><p>测试：在所有的epoch都完成后，会使用训练好的模型对测试集进行预测，并计算测试集的性能。</p></li></ul></li></ol><p>这段代码是一个完整的命名实体识别系统，包括数据预处理、模型定义、数据集构建和模型训练与测试四个主要部分。每个部分都有其特定的任务，并且这些部分共同协作，实现了从原始数据到预测结果的完整流程。</p><h3 id="14-螺旋矩阵的解题思路以及cpp代码"><a href="#14-螺旋矩阵的解题思路以及cpp代码" class="headerlink" title="14.螺旋矩阵的解题思路以及cpp代码"></a>14.螺旋矩阵的解题思路以及cpp代码</h3><p>螺旋矩阵问题是一个经典的算法问题，它要求按照螺旋的顺序遍历一个二维矩阵。下面是解题的一种思路：</p><ol><li>我们将整个矩阵看作一个层级结构，最外面一圈是一层，然后向里依次为下一层。</li><li>我们可以在每一层上进行上下左右四个方向的遍历。</li><li>遍历完一层后，我们向内移动到下一层，然后重复步骤2，直到所有元素都被遍历。</li></ol><p>这是相应的C++代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">if</span> (matrix.<span class="built_in">empty</span>()) <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> top = <span class="number">0</span>, bottom = matrix.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = matrix[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 从左到右</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = left; j &lt;= right; j++) result.<span class="built_in">push_back</span>(matrix[top][j]);</span><br><span class="line">        <span class="keyword">if</span> (++top &gt; bottom) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从上到下</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = top; i &lt;= bottom; i++) result.<span class="built_in">push_back</span>(matrix[i][right]);</span><br><span class="line">        <span class="keyword">if</span> (left &gt; --right) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从右到左</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = right; j &gt;= left; j--) result.<span class="built_in">push_back</span>(matrix[bottom][j]);</span><br><span class="line">        <span class="keyword">if</span> (top &gt; --bottom) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从下到上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = bottom; i &gt;= top; i--) result.<span class="built_in">push_back</span>(matrix[i][left]);</span><br><span class="line">        <span class="keyword">if</span> (++left &gt; right) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，<code>top</code>、<code>bottom</code>、<code>left</code>、<code>right</code>分别代表了当前层的上下左右边界。每次遍历完一个方向后，我们都更新相应的边界。比如从左到右遍历完后，我们就完成了最上方一行的遍历，所以下一步就应该开始遍历下一行，因此我们将<code>top</code>加1。其他三个方向的遍历也是类似的。在每次遍历完一个方向后，我们都检查是否已经遍历完所有的元素，如果是，就结束循环。</p><h3 id="15-模板特化"><a href="#15-模板特化" class="headerlink" title="15.模板特化"></a>15.模板特化</h3><p>在C++编程语言中，模板（Templates）是一个强大的工具，它允许我们编写泛型代码。我们可以为模板定义特定的特化版本，这被称为模板特化。它有两种形式：全特化和偏特化。</p><p><strong>全特化（Full Specialization）</strong>：当我们为模板的所有类型参数提供具体的类型时，就得到了一个全特化的模板。全特化是将模板的所有模板参数都替换为特定的类型或值。它相当于为特定类型的情况创建了一个新的模板，该模板与原始模板无关。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="comment">// 一般的模板</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;<span class="type">int</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 全特化的模板用于int</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>MyClass&lt;int&gt;</code>是一个全特化的模板类，因为我们为原始模板类的所有类型参数（在这个例子中是<code>T</code>）提供了具体的类型（在这个例子中是<code>int</code>）。</p><p><strong>偏特化（Partial Specialization）</strong>：偏特化是对模板的部分参数进行特化。我们可以为模板的一部分类型参数提供具体的类型，而另一部分则保留为泛型参数。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T1</span>, <span class="keyword">class</span> <span class="title class_">T2</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="comment">// 一般的模板</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>&lt;T, <span class="type">int</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 偏特化的模板用于第二个参数为int的情况</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>MyClass&lt;T, int&gt;</code>是一个偏特化的模板类，因为我们为原始模板类的部分类型参数（在这个例子中是<code>T2</code>）提供了具体的类型（在这个例子中是<code>int</code>），而另一部分（在这个例子中是<code>T1</code>）则保留为泛型参数。</p><p>总结一下，全特化和偏特化都是提供了一个特定类型的模板，但是全特化为所有类型参数提供了具体类型，而偏特化只为部分类型参数提供了具体类型。</p><p>模板特化（包括全特化和偏特化）在 C++ 中主要有以下几个作用：</p><ol><li><p><strong>优化特定情况下的性能</strong>：有时候，对某些特定类型，我们可能可以实现更高效的算法或数据结构。例如，一般的排序算法可能是快速排序，但如果元素类型是整数，我们可能会选择使用计数排序。通过模板特化，我们可以为特定类型实现这些优化。</p></li><li><p><strong>处理特定类型的特殊行为</strong>：有些类型可能需要特殊处理。例如，如果我们有一个模板函数，它需要对输入参数进行比较，大多数类型可能可以使用<code>==</code>运算符，但是如果类型是浮点数，我们可能需要用一个包含容差的比较函数。通过模板特化，我们可以为这些类型实现特殊的行为。</p></li><li><p><strong>扩展模板对类型的支持</strong>：有些类型可能不支持模板代码中需要的操作。例如，模板类可能需要类型具有默认构造函数，但是用户定义的类型可能没有。通过模板特化，我们可以提供对这些类型的支持。</p></li><li><p><strong>提供更好的错误信息</strong>：如果我们知道某些类型不能用于某个模板，我们可以通过特化那个模板并生成编译错误来提供更好的错误信息。</p></li></ol><p>注意，模板特化应当谨慎使用，因为过度使用模板特化会使代码变得复杂且难以理解和维护。在大多数情况下，泛型代码应当足够好。</p><h3 id="模板函数定义在-h"><a href="#模板函数定义在-h" class="headerlink" title="模板函数定义在.h"></a>模板函数定义在.h</h3><p>将模板函数的定义放在头文件（.h文件）中有以下几个优点：</p><ol><li><p>避免链接错误：模板函数的定义通常需要在使用它的代码中进行实例化，而编译器需要在编译期间生成相应的函数代码。将模板函数的定义放在头文件中可以确保在使用模板函数的地方，编译器能够访问到函数的定义，从而避免链接错误。</p></li><li><p>提高编译速度：将模板函数的定义放在头文件中可以减少编译时间。当模板函数的定义放在源文件（.cpp文件）中时，每次使用该模板函数时，编译器需要重新编译对应的源文件。而将模板函数的定义放在头文件中，可以使编译器在编译使用模板函数的代码时立即实例化该函数，从而减少了重新编译的开销。</p></li><li><p>可读性和可维护性：将模板函数的定义放在头文件中可以提高代码的可读性和可维护性。通过在头文件中定义模板函数，可以使代码更加紧凑和一致，方便开发人员阅读和理解代码。此外，头文件中的定义也可以更方便地进行修改和维护，不需要在多个源文件中进行同样的修改。</p></li><li><p>更广泛的可用性：将模板函数的定义放在头文件中可以使其更容易被其他源文件或模块使用。由于头文件是公共接口的一部分，其他源文件可以直接包含头文件，并使用其中定义的模板函数，而不需要额外的链接步骤或其他复杂的配置。</p></li></ol><p>需要注意的是，将模板函数的定义放在头文件中可能会导致代码膨胀，因为每个使用该模板函数的源文件都会生成相应的实例化代码。这可能会增加编译后的可执行文件的大小。在实际应用中，需要根据项目的需求和具体情况来权衡是否将模板函数的定义放在头文件中。</p><h3 id="1-C-手写单例模式"><a href="#1-C-手写单例模式" class="headerlink" title="1.C++手写单例模式"></a>1.C++手写单例模式</h3><p>以下是我提供的C++单例模式的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">static</span> Singleton instance; <span class="comment">// Guaranteed to be destroyed, instantiated on first use.</span></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>; <span class="comment">// Don&#x27;t allow copying</span></span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;) = <span class="keyword">delete</span>; <span class="comment">// Don&#x27;t allow assignment</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125; <span class="comment">// Private constructor</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个代码中定义了一个名为Singleton的类，这个类使用单例模式。我会逐行解释这个代码。</p><ul><li><p><code>class Singleton &#123;...&#125;;</code>：定义了一个名为Singleton的类。</p></li><li><p><code>public:</code>: 这个关键字定义了类的公有部分，这些成员和方法可以从类的外部访问。</p></li><li><p><code>static Singleton&amp; getInstance() &#123;...&#125;</code>: 这是一个静态方法，它返回Singleton类的一个引用。这个方法是访问Singleton实例的唯一方式。因为这个方法是静态的，所以你可以直接通过类（而不是对象）调用它，比如这样：<code>Singleton::getInstance()</code>。</p></li><li><p><code>static Singleton instance;</code>: 这行代码在<code>getInstance()</code>方法中定义了一个静态的Singleton对象。这个对象在方法第一次被调用时创建，并在程序结束时销毁。因为它是静态的，所以即使<code>getInstance()</code>被多次调用，这个对象也只会创建一次。这就实现了单例模式的主要目标：确保一个类只有一个实例。</p></li><li><p><code>return instance;</code>: 这行代码返回Singleton对象的引用。因为我们返回了引用，所以调用者获取的是Singleton对象的同一实例，而不是它的一个复制。</p></li><li><p><code>Singleton(const Singleton&amp;) = delete;</code>: 这行代码删除了Singleton类的拷贝构造函数。这意味着你不能复制Singleton对象。这是因为在单例模式中，我们只想有一个Singleton实例，所以不允许复制。</p></li><li><p><code>Singleton&amp; operator=(const Singleton&amp;) = delete;</code>: 这行代码删除了Singleton类的赋值操作符。这与删除拷贝构造函数的原因相同：防止复制Singleton实例。</p></li><li><p><code>private:</code>: 这个关键字定义了类的私有部分，这些成员和方法只能从类的内部访问。</p></li><li><p><code>Singleton() &#123;&#125;</code>: 这是Singleton类的构造函数，它是私有的。这意味着你不能从类的外部创建Singleton对象。这是因为在单例模式中，我们只想通过<code>getInstance()</code>方法创建Singleton的实例。</p></li></ul><h3 id="2-为什么这种单例模式可以保证线程安全"><a href="#2-为什么这种单例模式可以保证线程安全" class="headerlink" title="2.为什么这种单例模式可以保证线程安全"></a>2.为什么这种单例模式可以保证线程安全</h3><p>原因是C++11标准规定了局部静态变量的初始化是线程安全的。这意味着，在多线程环境下，只有一个线程能够初始化这个静态变量，而其他试图初始化这个变量的线程都会阻塞，直到该变量的初始化完成。</p><p>静态方法，返回静态对象</p><p>我把拷贝构造和赋值运算符都删除了，构造函数也变成私有的了</p><h3 id="3-重载和重写的区别"><a href="#3-重载和重写的区别" class="headerlink" title="3.重载和重写的区别"></a>3.重载和重写的区别</h3><h4 id="参数和作用域不同"><a href="#参数和作用域不同" class="headerlink" title="参数和作用域不同"></a>参数和作用域不同</h4><p>“重载”和”重写”都是面向对象编程中的两个重要概念，它们在使用和功能上有所不同：</p><ol><li>**重载(Overloading)**：重载发生在同一个类中或者在基类与派生类中，当有两个或更多的函数具有相同的函数名，但参数列表不同（参数类型、参数个数不同）时，我们就说这些函数被重载了。重载的目的是提供函数的多态性，让我们可以使用相同的函数名来进行不同的操作，从而提高代码的可读性和可用性。这在C++中是合法的，例如：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">double</span> a)</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>**重写(Overriding)**：重写是面向对象编程中的一个关键概念，当派生类定义了一个与基类在函数名、返回类型以及参数列表完全相同的函数时，我们就说派生类重写了基类的函数。重写的主要目的是提供多态性，让派生类可以用自己的方式来实现基类的行为。当基类的函数被声明为虚函数(<code>virtual</code>)时，派生类可以重写这个函数，例如：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; ... &#125; <span class="comment">// Override the base class method</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里，<code>Derived</code>类重写了<code>Base</code>类的<code>func()</code>方法。如果我们有一个指向<code>Derived</code>对象的<code>Base</code>指针，并调用<code>func()</code>，将会执行<code>Derived</code>类的<code>func()</code>方法，这就是多态性。</p><p>所以总结一下，重载和重写的主要区别在于：重载是在同一个作用域内，函数名相同但参数列表不同；重写是在不同的作用域（基类和派生类）内，函数名、返回类型以及参数列表都相同，但是函数的实现不同。</p><h3 id="4-函数重载、模板静态，重写动态"><a href="#4-函数重载、模板静态，重写动态" class="headerlink" title="4.函数重载、模板静态，重写动态"></a>4.函数重载、模板静态，重写动态</h3><ol><li>函数重载和函数&#x2F;类模板都是静态绑定，编译器在编译时就已经决定了调用哪个函数或实例化哪个模板。函数重写是动态绑定，运行时根据对象的实际类型来决定调用哪个函数。</li></ol><h3 id="5-const、static的用法"><a href="#5-const、static的用法" class="headerlink" title="5.const、static的用法"></a>5.const、static的用法</h3><ol><li><p><code>const</code>用于声明一个常量，其值在编译时就已确定且在运行期间不能被改变。<code>static</code>在C++中有多种用途，例如在类中声明静态成员，在函数中声明静态局部变量等。</p></li><li><p><code>const</code> 和 <code>static</code> 是 C++ 中的两个关键字，它们分别具有以下的用法和含义：</p><ol><li><p><strong>const</strong>：<code>const</code> 关键字用来声明一个常量。一旦被声明为 <code>const</code>，变量的值就不能被改变。</p><ul><li><p>用于基本数据类型：比如 <code>const int a = 10;</code>，表示 <code>a</code> 是一个常整数，其值不能被修改。</p></li><li><p>用于指针：<code>const</code> 可以修饰指针本身和指针指向的内容。例如，<code>int const *p</code> 或 <code>const int *p</code> 表示指向常整数的指针（即指针指向的整数不能被修改，但指针本身可以被修改）；<code>int * const p</code> 表示常指针（即指针本身不能被修改，但指针指向的整数可以被修改）；<code>const int * const p</code> 表示指向常整数的常指针（即指针本身和指针指向的整数都不能被修改）。</p></li><li><p>用于函数：在函数声明中，<code>const</code> 可以修饰返回值，表示返回值不可被修改；如果 <code>const</code> 放在成员函数后面，表示这个成员函数不能修改类的成员变量（除非它们被声明为 <code>mutable</code>）。</p></li></ul></li><li><p><strong>static</strong>：<code>static</code> 关键字在 C++ 中有多个用途，取决于它的上下文。</p><ul><li><p>用于全局变量和函数：<code>static</code> 可以限制全局变量或函数的可见性为文件内部，使得它们不会与其他文件中的同名变量或函数冲突。</p></li><li><p>用于局部变量：如果一个函数内的局部变量被声明为 <code>static</code>，那么它的生命周期将延长到程序结束，而不是函数返回时销毁。并且这个变量只会被初始化一次。</p></li><li><p>用于类的成员变量和成员函数：被声明为 <code>static</code> 的成员变量会被类的所有对象共享，而不是每个对象都有一份；<code>static</code> 成员函数则可以在不创建类的对象的情况下直接通过类名调用，而且 <code>static</code> 成员函数只能访问 <code>static</code> 成员变量，不能访问非 <code>static</code> 成员变量。</p></li></ul></li></ol><p>这是 <code>const</code> 和 <code>static</code> 在 C++ 中的主要用法，它们都是非常重要的关键字。</p></li></ol><h3 id="6-c语言中指针的用途"><a href="#6-c语言中指针的用途" class="headerlink" title="6.c语言中指针的用途"></a>6.c语言中指针的用途</h3><ol><li>在C语言中，指针用于存储变量的地址。它们允许对内存进行直接操作，这是实现动态数据结构（如链表和树）以及函数间的复杂交互（如通过引用参数传递）的关键。</li></ol><h3 id="7-void-有什么作用"><a href="#7-void-有什么作用" class="headerlink" title="7.void *有什么作用"></a>7.void *有什么作用</h3><ol><li><code>void *</code>是一个特殊类型的指针，可以指向任何类型的数据。它主要用于实现通用函数或数据结构。</li></ol><h3 id="8-了解原子变量吗"><a href="#8-了解原子变量吗" class="headerlink" title="8.了解原子变量吗"></a>8.了解原子变量吗</h3><ol><li>原子变量是一种特殊类型的变量，其所有操作（例如赋值、自增、自减等）都是原子操作，即这些操作在单个指令中完成，不会被其他线程中断。</li></ol><h3 id="9-原子变量和互斥锁有什么区别"><a href="#9-原子变量和互斥锁有什么区别" class="headerlink" title="9.原子变量和互斥锁有什么区别"></a>9.原子变量和互斥锁有什么区别</h3><ol><li>原子变量和互斥锁都可以用于解决多线程环境下的数据竞争问题。但它们的方式不同：原子变量通过确保操作的原子性来解决问题，而互斥锁通过限制一次只有一个线程可以访问数据来解决问题。</li></ol><h3 id="10-c-多态是怎么实现的"><a href="#10-c-多态是怎么实现的" class="headerlink" title="10.c++多态是怎么实现的"></a>10.c++多态是怎么实现的</h3><h4 id="1-静态多态性（编译时多态）"><a href="#1-静态多态性（编译时多态）" class="headerlink" title="1.静态多态性（编译时多态）"></a>1.静态多态性（编译时多态）</h4><h5 id="1-函数重载"><a href="#1-函数重载" class="headerlink" title="1.函数重载"></a>1.函数重载</h5><p>在同一作用域内，如果有两个或多个函数名相同但参数列表不同（包括参数的类型、个数或顺序），那么这些函数就是重载函数。函数重载可以看作是编译时多态性的一种形式，因为函数调用的具体版本是在编译时就确定的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void print(int i) &#123; std::cout &lt;&lt; &quot;Here is int: &quot; &lt;&lt; i &lt;&lt; std::endl; &#125;</span><br><span class="line">void print(double f) &#123; std::cout &lt;&lt; &quot;Here is float: &quot; &lt;&lt; f &lt;&lt; std::endl; &#125;</span><br><span class="line">void print(char const *c) &#123; std::cout &lt;&lt; &quot;Here is char: &quot; &lt;&lt; c &lt;&lt; std::endl; &#125;</span><br></pre></td></tr></table></figure><h5 id="2-函数-类模板"><a href="#2-函数-类模板" class="headerlink" title="2.函数&#x2F;类模板"></a>2.函数&#x2F;类模板</h5><p>模板是 C++ 中的一种特性，允许我们定义函数或类的通用版本，然后在需要的时候，编译器会根据我们提供的具体类型生成相应的特化版本。模板也可以看作是一种编译时多态性，因为模板的具体版本是在编译时根据参数类型生成的。例如：</p><p>template <typename T><br>void print(T arg) { std::cout &lt;&lt; “Here is generic: “ &lt;&lt; arg &lt;&lt; std::endl; }</p><h4 id="2-动态多态性（运行时多态）"><a href="#2-动态多态性（运行时多态）" class="headerlink" title="2.动态多态性（运行时多态）"></a>2.动态多态性（运行时多态）</h4><h4 id="1-虚函数"><a href="#1-虚函数" class="headerlink" title="1.虚函数"></a>1.虚函数</h4><p>C++中的多态性是通过虚函数（virtual function）和指向基类的指针或引用来实现的。这种多态性也被称为动态多态性或运行时多态性。让我们通过一个例子来理解它的工作原理：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Function of base\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Function of derived\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里，基类<code>Base</code>中的函数<code>func()</code>被声明为虚函数，派生类<code>Derived</code>中重写了这个函数。如果我们有一个指向<code>Derived</code>对象的<code>Base</code>指针并调用<code>func()</code>，那么会执行<code>Derived</code>类的<code>func()</code>函数，而不是<code>Base</code>类的<code>func()</code>函数。如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base* ptr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">ptr-&gt;<span class="built_in">func</span>();  <span class="comment">// Outputs: &quot;Function of derived&quot;</span></span><br></pre></td></tr></table></figure><p>这就是动态多态性。函数调用的实际版本在编译时并不确定，而是在运行时根据对象的实际类型来确定的。</p><p>这是通过什么机制实现的呢？C++的编译器在内部为每一个含有虚函数的类生成一个虚函数表（vtable），这个表中包含了指向类的虚函数的指针。每一个这种类的对象都有一个指向虚函数表的指针，通常被称为vptr。当我们调用一个对象的虚函数时，编译器会通过vptr找到相应的虚函数表，然后在表中找到正确的函数版本并调用它。</p><p>所以，当我们通过基类指针调用虚函数时，虽然编译器只知道这个指针的静态类型（在我们的例子中是<code>Base*</code>），但它会使用这个指针指向的对象的虚函数表来确定正确的函数版本。这就是C++中动态多态性的工作原理。</p><h3 id="11-虚函数的底层实现"><a href="#11-虚函数的底层实现" class="headerlink" title="11.虚函数的底层实现"></a>11.虚函数的底层实现</h3><h4 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h4><p>C++的编译器在内部为每一个含有虚函数的类生成一个虚函数表（vtable），这个表中包含了指向类的虚函数的指针。每一个这种类的对象都有一个指向虚函数表的指针，通常被称为vptr。当我们调用一个对象的虚函数时，编译器会通过vptr找到相应的虚函数表，然后在表中找到正确的函数版本并调用它。</p><h3 id="12-c-智能指针用过吗，有什么区别"><a href="#12-c-智能指针用过吗，有什么区别" class="headerlink" title="12.c++智能指针用过吗，有什么区别"></a>12.c++智能指针用过吗，有什么区别</h3><ol><li>C++中的智能指针包括<code>unique_ptr</code>，<code>shared_ptr</code>和<code>weak_ptr</code>。<code>unique_ptr</code>表示唯一拥有对象的指针，<code>shared_ptr</code>允许多个指针共享同一对象，<code>weak_ptr</code>则是一种不控制对象生命周期的指针。</li></ol><h4 id="唯一unique-共享，弱"><a href="#唯一unique-共享，弱" class="headerlink" title="唯一unique,共享，弱"></a>唯一unique,共享，弱</h4><h3 id="13-为什么有了shared-ptr还需要unique-ptr"><a href="#13-为什么有了shared-ptr还需要unique-ptr" class="headerlink" title="13.为什么有了shared_ptr还需要unique_ptr"></a>13.为什么有了shared_ptr还需要unique_ptr</h3><h4 id="额外开销，引用计数"><a href="#额外开销，引用计数" class="headerlink" title="额外开销，引用计数"></a>额外开销，引用计数</h4><ol><li>尽管<code>shared_ptr</code>可以用于多个所有者共享所有权，但这会导致额外的开销（如引用计数）。而<code>unique_ptr</code>则为单一所有权提供了一种低开销的方式。当你不需要共享所有权时，<code>unique_ptr</code>是一个更好的选择。</li></ol><h3 id="14-为什么有了typedef之后还需要使用using"><a href="#14-为什么有了typedef之后还需要使用using" class="headerlink" title="14.为什么有了typedef之后还需要使用using"></a>14.为什么有了typedef之后还需要使用using</h3><h4 id="using可以定义模板别名"><a href="#using可以定义模板别名" class="headerlink" title="using可以定义模板别名"></a>using可以定义模板别名</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">using Vec = std::vector&lt;T, std::allocator&lt;T&gt;&gt;;</span><br><span class="line"></span><br><span class="line">// 使用定义的别名</span><br><span class="line">Vec&lt;int&gt; vec;</span><br></pre></td></tr></table></figure><ol><li><code>typedef</code>和<code>using</code>都可以用来定义类型别名。但<code>using</code>在某些方面更灵活，比如它可以用于模板别名，而<code>typedef</code>则不能。</li></ol><h3 id="15-对象指针被delete后调用成员函数会怎么样"><a href="#15-对象指针被delete后调用成员函数会怎么样" class="headerlink" title="15.对象指针被delete后调用成员函数会怎么样"></a>15.对象指针被delete后调用成员函数会怎么样</h3><h4 id="悬空指针"><a href="#悬空指针" class="headerlink" title="悬空指针"></a>悬空指针</h4><p>当一个对象的指针被 <code>delete</code> 后，该对象的内存将被释放，对象的析构函数也会被调用。此后，再次使用该指针将是非法的，因为它现在是一个悬空指针（dangling pointer），也就是说它指向的内存区域已经不再有效。</p><p>如果在 <code>delete</code> 一个对象后，再试图通过该对象的指针调用其成员函数，结果是未定义的。在最好的情况下，程序可能会立即崩溃，使你意识到出现了问题。在最坏的情况下，程序可能会继续运行，但会产生错误的结果，或者在不可预见的未来的某一时刻崩溃。</p><p>class Test {<br>public:<br>    void func() { std::cout &lt;&lt; “Function called\n”; }<br>};</p><p>Test* ptr &#x3D; new Test();<br>delete ptr;<br>ptr-&gt;func();  &#x2F;&#x2F; 未定义行为</p><h4 id="未定义行为，崩溃或者其他错误"><a href="#未定义行为，崩溃或者其他错误" class="headerlink" title="未定义行为，崩溃或者其他错误"></a>未定义行为，崩溃或者其他错误</h4><ol><li>如果一个对象的指针被<code>delete</code>后，再调用其成员函数，会导致未定义行为。通常，这会导致崩溃或其他错误。</li></ol><h3 id="16-程序崩溃后的信息如何查看"><a href="#16-程序崩溃后的信息如何查看" class="headerlink" title="16.程序崩溃后的信息如何查看"></a>16.程序崩溃后的信息如何查看</h3><p>当一个程序崩溃时，操作系统通常会生成一个包含了许多有关崩溃情况的信息的核心转储文件（core dump）。这个文件可以用调试器（如 gdb 或 lldb）来查看，以确定崩溃发生在哪里，以及在崩溃时程序的状态是什么。</p><p>在 Unix&#x2F;Linux 系统中，你可以使用 gdb 来查看核心转储文件：</p><h4 id="gdb-c-core-your-program"><a href="#gdb-c-core-your-program" class="headerlink" title="gdb -c core .&#x2F;your_program"></a>gdb -c core .&#x2F;your_program</h4><p>这将打开 gdb 并加载核心转储文件。然后你可以使用 gdb 的各种命令（如 <code>bt</code> 来查看堆栈跟踪）来查看崩溃时的信息。</p><p>另外，有些情况下，操作系统可能配置为不生成核心转储文件。在这种情况下，你可能需要修改系统的配置以启用核心转储。</p><p>在 Unix&#x2F;Linux 系统中，你可以使用 <code>ulimit</code> 命令来修改系统的核心转储大小限制。如果这个限制被设定为 0，那么核心转储文件就不会被创建。你可以使用以下命令来移除这个限制：</p><h4 id="ulimit-c-unlimited"><a href="#ulimit-c-unlimited" class="headerlink" title="ulimit -c unlimited"></a>ulimit -c unlimited</h4><p>这个命令将核心转储文件的最大大小设置为“无限制”，意味着无论程序崩溃时使用了多少内存，都会创建一个完整的核心转储文件。</p><p>请注意，这个设置只对当前的 shell 会话有效。如果你想要让这个设置在每次登录时都自动生效，你需要将这个命令添加到你的 shell 初始化文件中（例如，如果你使用的是 bash，那么你可能需要将这个命令添加到 <code>~/.bashrc</code> 文件中）。</p><p>此外，你还需要确认你的系统是允许核心转储文件被创建的。有些系统可能默认禁止创建核心转储文件，或者限制核心转储文件的存储位置。具体的设置方法取决于你使用的具体的操作系统。例如，在某些 Linux 发行版中，你可能需要编辑 <code>/etc/sysctl.conf</code> 或 <code>/etc/security/limits.conf</code> 文件来修改相关的设置。</p><h3 id="17-gdb使用什么命令查看程序崩溃时的调用栈"><a href="#17-gdb使用什么命令查看程序崩溃时的调用栈" class="headerlink" title="17.gdb使用什么命令查看程序崩溃时的调用栈"></a>17.gdb使用什么命令查看程序崩溃时的调用栈</h3><h4 id="bt-backtrace"><a href="#bt-backtrace" class="headerlink" title="bt backtrace"></a>bt backtrace</h4><p>在 gdb 中，你可以使用 <code>bt</code>（backtrace）命令来查看在程序崩溃时的调用栈。这个命令将显示从最近的函数调用开始的一系列函数调用，这可以帮助你追踪到导致崩溃的代码位置。</p><p>这将显示出调用栈的一个列表，其中包括每个函数调用的函数名、参数和源代码行号（如果有的话）。</p><p>假设你有一个名为 <code>test.cpp</code> 的 C++ 程序，内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">functionB</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;In function B, x = &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">int</span>* ptr = <span class="literal">nullptr</span>;</span><br><span class="line">    *ptr = x;  <span class="comment">// 会导致程序崩溃的行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">functionA</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;In function A, x = &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">functionB</span>(x+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">functionA</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序将会在 <code>functionB</code> 中尝试解引用一个空指针，从而导致崩溃。</p><p>如果你使用 gdb 运行这个程序并且在崩溃时查看调用栈，你将看到类似以下的输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -g -o <span class="built_in">test</span> test.cpp</span><br><span class="line">$ gdb ./test</span><br><span class="line">(gdb) run</span><br><span class="line">Starting program: /path/to/test </span><br><span class="line">In <span class="keyword">function</span> A, x = 5</span><br><span class="line">In <span class="keyword">function</span> B, x = 6</span><br><span class="line"></span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">0x00000000004008f9 <span class="keyword">in</span> functionB (x=6) at test.cpp:6</span><br><span class="line">6        *ptr = x;  // 会导致程序崩溃的行</span><br><span class="line">(gdb) bt</span><br><span class="line"><span class="comment">#0  0x00000000004008f9 in functionB (x=6) at test.cpp:6</span></span><br><span class="line"><span class="comment">#1  0x000000000040093c in functionA (x=5) at test.cpp:11</span></span><br><span class="line"><span class="comment">#2  0x000000000040096d in main () at test.cpp:16</span></span><br></pre></td></tr></table></figure><h4 id="bt看具体调用关系，锁定具体崩溃点"><a href="#bt看具体调用关系，锁定具体崩溃点" class="headerlink" title="bt看具体调用关系，锁定具体崩溃点"></a>bt看具体调用关系，锁定具体崩溃点</h4><p>从这个调用栈，你可以看到程序从 <code>main</code> 调用 <code>functionA</code>，然后调用 <code>functionB</code>，最后在 <code>test.cpp</code> 的第 6 行崩溃。</p><h3 id="18-在-gdb-中，你可以使用-x-命令来检查内存中的内容。"><a href="#18-在-gdb-中，你可以使用-x-命令来检查内存中的内容。" class="headerlink" title="18.在 gdb 中，你可以使用 x 命令来检查内存中的内容。"></a>18.在 gdb 中，你可以使用 <code>x</code> 命令来检查内存中的内容。</h3><p><code>x</code> 命令后面可以跟一些参数来指定你想要查看的内存地址和格式。</p><p>例如，如果你想要查看位于地址 <code>0x12345678</code> 的 4 个字节的十六进制内容，你可以使用如下命令：</p><p>(gdb) x&#x2F;1xw 0x12345678</p><p>这里，<code>/1xw</code> 表示你想要查看 1 个以十六进制（<code>x</code>）格式显示的字（<code>w</code>，即 4 个字节）。</p><p>需要注意的是，<code>x</code> 命令允许你查看任意的内存地址，但是如果你试图查看一个无效的内存地址（例如，一个你的程序没有权限访问的地址），那么 gdb 将会显示一个错误信息。</p><h3 id="19-linux内存分为哪几个区域"><a href="#19-linux内存分为哪几个区域" class="headerlink" title="19.linux内存分为哪几个区域"></a>19.linux内存分为哪几个区域</h3><p>Linux内存分为以下几个区域：</p><ol><li><h4 id="文本段（Text-Segment）："><a href="#文本段（Text-Segment）：" class="headerlink" title="文本段（Text Segment）："></a><strong>文本段（Text Segment）</strong>：</h4><p>这部分内存存储了程序的代码。这是只读的，防止程序在运行过程中误修改自己的指令。</p></li><li><h4 id="数据段（Initialized-Data-Segment）："><a href="#数据段（Initialized-Data-Segment）：" class="headerlink" title="数据段（Initialized Data Segment）："></a><strong>数据段（Initialized Data Segment）</strong>：</h4><p>也被称为数据段，这部分内存存储了程序的全局变量和静态变量。这部分内存又可以细分为初始化的部分（即程序员已经赋予初始值的全局或静态变量）和未初始化的部分（BSS，Block Started by Symbol，程序员没有显式赋予初始值的全局或静态变量）。</p></li><li><h4 id="堆（Heap）："><a href="#堆（Heap）：" class="headerlink" title="堆（Heap）："></a><strong>堆（Heap）</strong>：</h4><p>堆是程序运行过程中动态分配内存的区域。程序员可以在任何时候请求分配一块特定大小的内存，用来存储程序运行过程中产生的数据。这部分内存的大小不是固定的，可以根据需要进行扩展。</p></li><li><h4 id="栈（Stack）："><a href="#栈（Stack）：" class="headerlink" title="栈（Stack）："></a><strong>栈（Stack）</strong>：</h4><p>栈用来存储程序运行过程中的局部变量和函数调用的信息。每当一个函数被调用时，会有一个新的栈帧被压入栈中，用来存储这个函数的局部变量和一些必要的信息，以便函数返回时能够正确地恢复程序的状态。栈是自动管理的，函数调用结束后，对应的栈帧会被自动弹出。</p></li></ol><h4 id="5-文件映射和匿名映射区"><a href="#5-文件映射和匿名映射区" class="headerlink" title="5.文件映射和匿名映射区"></a>5.文件映射和匿名映射区</h4><p>在 Linux 系统中，映射区（Mapped Segment）也是虚拟内存的一部分。它可以进一步划分为文件映射区和匿名映射区：</p><ol><li><p><strong>文件映射区</strong>：当使用 mmap 系统调用将一个文件映射到内存时，就会创建一个文件映射区。这个区域的内容直接对应到文件的内容。当你修改这个区域的内容时，相应的文件内容也会被修改。这使得对大文件的操作变得更高效，因为你可以直接在内存中对文件进行操作，而不需要逐个字节地读写文件。同时，文件映射区也用于共享内存，因为多个进程可以同时映射同一个文件，实现内存共享。</p></li><li><p><strong>匿名映射区</strong>：匿名映射区不直接对应于任何文件，而是直接分配的内存区域。当你调用 mmap 系统调用，但不关联任何文件时，就会创建一个匿名映射区。除了 mmap 系统调用，使用 malloc、calloc 等函数分配内存时，内部也可能通过创建匿名映射区来获取内存。当然，具体行为取决于 C 库的实现。在某些实现中，小的内存请求可能会从堆中分配，而大的内存请求则可能会通过创建匿名映射区来满足。</p></li></ol><p>总的来说，文件映射区和匿名映射区提供了更加灵活的内存管理方式，使得操作系统可以更有效地利用和管理内存资源。</p><h4 id="6-内核空间（Kernel-Space）："><a href="#6-内核空间（Kernel-Space）：" class="headerlink" title="6.内核空间（Kernel Space）："></a>6.<strong>内核空间（Kernel Space）</strong>：</h4><p>这部分内存是被操作系统内核使用的，存储内核代码和数据。用户程序不能直接访问这部分内存，防止用户程序误操作影响系统的稳定运行。</p><p>这些内存区域在程序的虚拟内存空间中各占有一定的位置，但它们的大小（除了文本段和数据段）在程序运行过程中可能会发生变化。</p><h3 id="20-程序从源代码到二进制的转换流程"><a href="#20-程序从源代码到二进制的转换流程" class="headerlink" title="20.程序从源代码到二进制的转换流程"></a>20.程序从源代码到二进制的转换流程</h3><h4 id="预处理-Preprocessing"><a href="#预处理-Preprocessing" class="headerlink" title="预处理(Preprocessing):"></a><strong>预处理(Preprocessing)</strong>:</h4><ul><li><h4 id="这是编译过程的第一步，预处理器（preprocessor）会接收到源代码，并执行所有以-开头的指令，比如-include-和-define。"><a href="#这是编译过程的第一步，预处理器（preprocessor）会接收到源代码，并执行所有以-开头的指令，比如-include-和-define。" class="headerlink" title="这是编译过程的第一步，预处理器（preprocessor）会接收到源代码，并执行所有以 # 开头的指令，比如 #include 和 #define。"></a>这是编译过程的第一步，预处理器（preprocessor）会接收到源代码，并执行所有以 # 开头的指令，比如 #include 和 #define。</h4></li><li><p>C++ 或 C 语言的预处理是编译过程的第一步。预处理器会对源代码进行一些文本上的修改，为后续的编译过程做准备。预处理的主要任务包括：</p><ol><li><p><strong>处理包含文件（#include）</strong>：预处理器会找到 #include 指示的头文件，并将其内容插入到 #include 指示的位置。这样，编译器在编译源代码时就可以看到这些头文件中的声明和定义。</p></li><li><p><strong>展开宏定义（#define）</strong>：预处理器会找到所有的宏定义，并将源代码中使用这些宏的地方替换为宏的定义。这是一种简单的文本替换过程。</p></li><li><p><strong>处理条件编译指令（#if, #ifdef, #ifndef, #else, #elif, #endif）</strong>：预处理器会根据条件编译指令来决定是否包含某段代码。这使得你可以根据不同的条件（如不同的平台或编译选项）来编译不同的代码。</p></li><li><p><strong>处理其他预处理指令</strong>：预处理器还处理其他预处理指令，如 #error, #pragma 等。</p></li><li><p><strong>删除注释</strong>：预处理器将会删除所有的注释，将它们替换为一个空格。</p></li><li><p><strong>添加行控制信息</strong>：预处理器会添加一些特殊的行控制信息，使得编译器在报告错误和警告时能够指出正确的源代码行数。</p></li></ol><p>预处理之后的结果是一份“预处理过的源代码”，它将被送入编译器进行编译。在大多数情况下，你不需要直接查看预处理过的源代码，但在调试宏定义或包含文件的问题时，查看预处理过的源代码可能会很有帮助。</p></li></ul><h4 id="编译-Compilation"><a href="#编译-Compilation" class="headerlink" title="编译(Compilation):"></a>编译(Compilation):</h4><ul><li>编译器接着会将预处理过后的代码转换成汇编语言。编译过程也会对代码进行优化。</li></ul><h4 id="汇编-Assembly"><a href="#汇编-Assembly" class="headerlink" title="汇编(Assembly):"></a><strong>汇编(Assembly)</strong>:</h4><ul><li>汇编器（assembler）将汇编代码转换为机器语言指令，通常这会生成一个目标文件（object file）。</li></ul><h4 id="链接-Linking"><a href="#链接-Linking" class="headerlink" title="链接(Linking):"></a><strong>链接(Linking)</strong>:</h4><ul><li><h4 id="链接器（linker）将多个目标文件以及库连接（link）在一起，生成一个可执行文件。链接器解决了源文件间的依赖关系。"><a href="#链接器（linker）将多个目标文件以及库连接（link）在一起，生成一个可执行文件。链接器解决了源文件间的依赖关系。" class="headerlink" title="链接器（linker）将多个目标文件以及库连接（link）在一起，生成一个可执行文件。链接器解决了源文件间的依赖关系。"></a>链接器（linker）将多个目标文件以及库连接（link）在一起，生成一个可执行文件。链接器解决了源文件间的依赖关系。</h4></li></ul><h3 id="21-makefile和cmake的区别"><a href="#21-makefile和cmake的区别" class="headerlink" title="21.makefile和cmake的区别"></a>21.makefile和cmake的区别</h3><h4 id="1-传统与现代"><a href="#1-传统与现代" class="headerlink" title="1.传统与现代"></a>1.传统与现代</h4><ul><li><strong>Makefile</strong> 是一个传统的构建工具，它使用名为 Make 的工具来解析和执行 Makefile 中的指令。在一个 Makefile 中，你会指定一系列的目标（targets），每个目标都关联了一系列的依赖（dependencies）和一系列用于生成这个目标的命令。当你运行 Make 时，它会检查每个目标的依赖是否是最新的，如果不是，就执行相关命令来更新目标。</li><li><strong>CMake</strong> 是一个更现代的构建工具，它可以生成 Makefile 或其他构建系统（如 Ninja 或 Visual Studio 的项目文件）的输入文件。CMake 用一种名为 CMakeLists.txt 的文件来描述如何构建项目。CMake 语法比 Makefile 更简单，而且 CMake 提供了更强大的功能，比如自动依赖管理、包查找和跨平台构建。使用 CMake，你只需要描述你的项目如何构建，而不需要关心具体在哪种系统下构建，这对于大型跨平台项目来说是非常有用的。</li></ul><h3 id="22-单例模式"><a href="#22-单例模式" class="headerlink" title="22.单例模式"></a>22.单例模式</h3><p>单例模式是一种创建型模式，它用来确保一个类只有一个实例，并提供一个全局访问点。</p><p>以下是单例模式的一些特性：</p><h4 id="单一实例："><a href="#单一实例：" class="headerlink" title="单一实例："></a><strong>单一实例</strong>：</h4><ul><li>单例类只能创建一个对象。</li></ul><h4 id="全局访问点："><a href="#全局访问点：" class="headerlink" title="全局访问点："></a><strong>全局访问点</strong>：</h4><ul><li>单例类提供了一个全局访问该实例的方法，通常是一个静态方法。</li></ul><h4 id="自我管理："><a href="#自我管理：" class="headerlink" title="自我管理："></a><strong>自我管理</strong>：</h4><ul><li>单例类负责创建其自身的唯一实例，并确保其他对象不能创建新的实例。</li></ul><p>在很多情况下，单例模式都很有用，例如数据库连接、日志记录、驱动器对象、缓存、线程池、配置设置等。</p><h3 id="23-工厂模式"><a href="#23-工厂模式" class="headerlink" title="23.工厂模式"></a>23.工厂模式</h3><p>客户端可以不关心具体实现代码</p><p>工厂模式也是一种创建型模式，它提供了一种创建对象的最佳方式。在工厂模式中，对象的创建被移动到了一个称为工厂的类的方法中，这样，在需要创建对象的地方，就不需要关心对象创建的细节。</p><p>工厂模式有三种形式：简单工厂模式（也叫静态工厂方法）、工厂方法模式和抽象工厂模式。</p><ul><li><strong>简单工厂模式</strong>：有一个工厂对象决定创建哪一种产品类的实例。但是它直接创建实例，这个工厂类通常使用静态方法，通过接收的参数的不同来返回不同的对象实例，被外界直接调用，创建所需的产品对象。</li><li><strong>工厂方法模式</strong>：提供一个用于创建对象的接口，但是实际的对象是由子类决定创建的。</li><li><strong>抽象工厂模式</strong>：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。</li></ul><p>工厂模式主要在处理大量具有共同特性的小型类时显得非常有用，特别是当具体类可能在运行时刻被改变时。</p><p><strong>工厂模式</strong>的优点包括：</p><h4 id="解耦："><a href="#解耦：" class="headerlink" title="解耦："></a><strong>解耦</strong>：</h4><p>用户不需要知道它所创建的对象的类。用户只需要知道所创建的对象实现了哪些接口或者具有哪些方法或属性即可，具体的类名并不重要。这意味着，如果你改变了对象的具体实现，用户的代码不需要改变。</p><h4 id="代码复用："><a href="#代码复用：" class="headerlink" title="代码复用："></a><strong>代码复用</strong>：</h4><p>如果创建对象的过程涉及到很多步骤，那么这些步骤可以在工厂方法中实现，而不是在每个需要创建对象的地方都复制这些代码。</p><h4 id="易于控制和管理对象的创建："><a href="#易于控制和管理对象的创建：" class="headerlink" title="易于控制和管理对象的创建："></a><strong>易于控制和管理对象的创建</strong>：</h4><p>由于创建对象的代码集中在工厂方法中，所以更易于控制和管理对象的创建。</p><h3 id="创建型模式的含义："><a href="#创建型模式的含义：" class="headerlink" title="创建型模式的含义："></a><strong>创建型模式</strong>的含义：</h3><p>创建型模式是设计模式的一种类型，主要解决的是对象的创建问题。</p><p>在面向对象编程中，对象的创建通常需要依赖具体的类，但依赖具体的类又降低了代码的灵活性和可复用性。</p><p>创建型模式通过某种方式控制这个对象的创建过程，让代码可以在<strong>不确定具体类</strong>的情况下创建对象，或者<strong>可以在运行时刻确定具体类，或者可以让用户自己选择具体类</strong>。</p><p>创建型模式包括：工厂方法模式（Factory Method）、抽象工厂模式（Abstract Factory）、生成器模式（Builder）、原型模式（Prototype）和单例模式（Singleton）。</p><h3 id="24-迭代器"><a href="#24-迭代器" class="headerlink" title="24.迭代器"></a>24.迭代器</h3><p>在 C++11 中，迭代器（Iterator）是一个泛型对象，用于遍历和访问容器（如数组、向量、链表等）中的元素。迭代器提供了一种统一的方式来访问容器中的元素，而不需要暴露容器的内部结构。</p><p>迭代器提供了以下几种基本操作：</p><ol><li><p><strong>解引用（Dereference）</strong>：迭代器可以通过解引用操作符 <code>*</code> 来获取当前指向的元素的值。</p></li><li><p><strong>自增（Increment）</strong>：迭代器可以通过自增操作符 <code>++</code> 来将迭代器前进到容器中的下一个元素。</p></li><li><p><strong>比较（Comparison）</strong>：迭代器可以通过比较操作符（如 <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>）来比较两个迭代器的相对位置。</p></li></ol><p>C++11 中引入了更多类型的迭代器，包括：</p><ol><li><p><strong>正向迭代器（Forward Iterator）</strong>：它允许遍历容器中的元素，并且可以通过自增操作符前进到下一个元素。</p></li><li><p><strong>双向迭代器（Bidirectional Iterator）</strong>：它除了具有正向迭代器的功能外，还可以通过自减操作符后退到上一个元素。</p></li><li><p><strong>随机访问迭代器（Random Access Iterator）</strong>：它具有双向迭代器的功能，并且支持常数时间的随机访问，可以通过加减操作符进行任意跳跃。</p></li></ol><p>C++11 还引入了一些更高级的迭代器，如反向迭代器（Reverse Iterator）和常量迭代器（Const Iterator），它们提供了对容器元素的反向遍历和只读访问。</p><p>迭代器为 C++ 的标准容器提供了一种通用的遍历和访问方式，使得代码更加通用和可移植。你可以使用迭代器来遍历容器中的元素，执行某些操作，或者修改容器的内容。</p><h3 id="25-泛型对象"><a href="#25-泛型对象" class="headerlink" title="25.泛型对象"></a>25.泛型对象</h3><p>在 C++ 中，泛型对象（Generic Object）指的是能够存储和操作不特定类型数据的对象。它是通过使用模板（Template）来实现的。</p><p>泛型对象的关键在于参数化类型，即在定义对象时，使用模板来指定其数据类型。通过这种方式，可以编写出能够适用于不同类型数据的通用代码，而不需要为每种类型都单独编写代码。</p><p>泛型对象提供了一种抽象的方式来处理不同类型的数据，使得代码更加灵活、可重用和可扩展。它们可以用于各种情况，如容器类、算法、函数模板等。</p><p>在 C++ 中，泛型对象可以通过模板类（Template Class）或函数模板（Function Template）来实现。模板类允许你定义能够存储和操作各种类型数据的通用类，而函数模板则允许你定义能够处理各种类型参数的通用函数。</p><p>通过泛型对象，可以避免在编写代码时重复编写相似的逻辑，减少了代码的冗余，并提高了代码的可读性和维护性。它是 C++ 中强大的特性之一，为编写通用和灵活的代码提供了强大的支持。</p><h3 id="26-linux命令"><a href="#26-linux命令" class="headerlink" title="26.linux命令"></a>26.linux命令</h3><p>在Linux上开发webserver时，你可能需要用到以下的一些命令：</p><h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><ol><li>：如<code>ls</code>（列出目录内容），<code>cd</code>（改变当前目录），<code>mkdir</code>（创建新目录），<code>rm</code>（删除文件或目录），<code>cp</code>（复制文件或目录），<code>mv</code>（移动或重命名文件或目录），<code>cat</code>（查看文件内容），<code>nano</code>、<code>vim</code>或<code>emacs</code>（编辑文件）。</li></ol><h4 id="编译和构建："><a href="#编译和构建：" class="headerlink" title="编译和构建："></a>编译和构建：</h4><ol><li>如<code>gcc</code>或<code>g++</code>（编译C或C++程序），<code>make</code>（使用Makefile文件自动编译和链接程序），<code>cmake</code>（跨平台自动构建系统），<code>ld</code>（链接器）。</li></ol><h4 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h4><p>：如<code>git</code>（分布式版本控制系统），你可能会使用<code>git clone</code>（克隆仓库），<code>git pull</code>（更新本地仓库），<code>git push</code>（推送更改到远程仓库），<code>git commit</code>（提交更改），<code>git checkout</code>（切换分支或恢复文件）等命令。</p><h4 id="网络："><a href="#网络：" class="headerlink" title="网络："></a>网络：</h4><ol><li>如<code>ping</code>（检查网络连通性），<code>netstat</code>（查看网络状态），<code>ifconfig</code>（配置网络接口），<code>ssh</code>（远程登录），<code>scp</code>（远程复制文件），<code>curl</code>或<code>wget</code>（下载网络资源）。</li></ol><h4 id="性能分析："><a href="#性能分析：" class="headerlink" title="性能分析："></a><strong>性能分析</strong>：</h4><ol><li>如<code>top</code>（查看进程状态），<code>ps</code>（查看当前进程），<code>vmstat</code>（查看系统资源使用情况），<code>iostat</code>（查看I&#x2F;O统计信息），<code>lsof</code>（查看打开的文件）。</li></ol><h4 id="调试和测试："><a href="#调试和测试：" class="headerlink" title="调试和测试："></a><strong>调试和测试</strong>：</h4><ol><li>如<code>gdb</code>（GNU调试器），<code></code>（内存调试工具），<code>strace</code>（追踪系统调用和信号）。</li></ol><h4 id="包管理器"><a href="#包管理器" class="headerlink" title="包管理器"></a><strong>包管理器</strong></h4><ol><li>：如<code>apt</code>、<code>yum</code>或<code>dnf</code>，用来安装、更新或删除系统软件包。</li></ol><h4 id="权限和所有权："><a href="#权限和所有权：" class="headerlink" title="权限和所有权："></a><strong>权限和所有权</strong>：</h4><p>如<code>chmod</code>（修改文件权限），<code>chown</code>（更改文件所有者）。</p><p>这只是一个基础列表，根据具体的开发需求，你可能需要使用到其他的命令或工具。在开发过程中，熟练使用这些命令可以大大提高你的效率。</p><h3 id="27-gdb命令"><a href="#27-gdb命令" class="headerlink" title="27.gdb命令"></a>27.gdb命令</h3><ol><li><p><code>run</code>：启动程序的执行。</p></li><li><p><code>break</code>：设置断点，可以在特定的代码行上设置断点，例如 <code>break main</code> 或 <code>break filename:line_number</code>。</p></li><li><p><code>continue</code>：继续程序的执行，直到下一个断点或程序结束。</p></li><li><p><code>next</code>：逐过程地执行程序，遇到函数调用时不会进入函数体。</p></li><li><p><code>step</code>：逐语句地执行程序，遇到函数调用时会进入函数体。</p></li><li><p><code>print</code>：打印变量的值，例如 <code>print variable_name</code>。</p></li><li><p><code>info breakpoints</code>：查看当前设置的所有断点。</p></li><li><p><code>backtrace</code>：打印当前的函数调用栈。</p></li><li><p><code>watch</code>：设置观察点，当指定的表达式值发生变化时中断程序的执行。</p></li><li><p><code>finish</code>：执行当前函数的剩余部分，并返回到调用该函数的地方。</p></li><li><p><code>delete</code>：删除断点，可以删除指定的断点或所有断点。</p></li><li><p><code>quit</code>：退出 GDB 调试。</p></li></ol><h3 id="27-reactor和proactor"><a href="#27-reactor和proactor" class="headerlink" title="27.reactor和proactor"></a>27.reactor和proactor</h3><p>您给出了一个很好的对Reactor模式和Proactor模式的比较。确实，这两种模式的主要区别在于I&#x2F;O操作的处理方式，以及工作线程的职责。</p><h4 id="Reactor模式："><a href="#Reactor模式：" class="headerlink" title="Reactor模式："></a><strong>Reactor模式</strong>：</h4><p>Reactor模式中，主线程（也称为I&#x2F;O处理单元或事件分发器）负责监听文件描述符上的事件，如新连接请求、数据可读等。当检测到事件发生时，主线程会将事件通知工作线程（也称为逻辑单元）。工作线程则负责处理这些事件，如读写数据、接受新连接、处理客户请求等。在这个模式中，I&#x2F;O操作通常是同步的，即工作线程在处理一个事件时需要阻塞等待I&#x2F;O操作的完成，无法同时处理其他事件。这种模式适用于处理<strong>短暂的、非阻塞</strong>的事件，以及对性能要求不高的应用。</p><h4 id="Proactor模式："><a href="#Proactor模式：" class="headerlink" title="Proactor模式："></a><strong>Proactor模式</strong>：</h4><p>Proactor模式中，主线程和内核负责处理I&#x2F;O操作，如读写数据、接受新连接等。当I&#x2F;O操作完成后，主线程会将结果通知工作线程。工作线程仅负责<strong>处理业务逻辑</strong>，如处理客户请求等。在这个模式中，I&#x2F;O操作通常是异步的，即主线程和内核在处理I&#x2F;O操作时不会阻塞，可以同时处理多个事件。这种模式适用于处理长时间阻塞的事件，以及对性能要求较高的应用。</p><p>根据应用的需求和场景，开发者可以选择使用Reactor模式或者Proactor模式。在实际项目中，也可以根据不同的任务和负载来组合使用这两种模式，以获得最佳的性能和效果。</p><h4 id="模拟的proactor"><a href="#模拟的proactor" class="headerlink" title="模拟的proactor"></a>模拟的proactor</h4><ul><li>主线程往epoll内核事件表注册socket上的读就绪事件。</li><li>主线程调用epoll_wait等待socket上有数据可读</li><li>当socket上有数据可读，epoll_wait通知主线程,主线程从socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。</li><li>睡眠在请求队列上某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件</li><li>主线程调用epoll_wait等待socket可写。</li><li>当socket上有数据可写，epoll_wait通知主线程。主线程往socket上写入服务器处理客户请求的结果。</li></ul><h3 id="28-半同步-半异步模式工作流程"><a href="#28-半同步-半异步模式工作流程" class="headerlink" title="28.半同步&#x2F;半异步模式工作流程"></a>28.半同步&#x2F;半异步模式工作流程</h3><ul><li>同步线程用于处理客户逻辑</li><li>异步线程用于处理I&#x2F;O事件</li><li>异步线程监听到客户请求后，就将其封装成请求对象并插入请求队列中</li><li>请求队列将通知某个工作在<strong>同步模式的工作线程</strong>来读取并处理该请求对象</li><li></li><li>主线程充当异步线程，负责监听所有socket上的事件</li><li>若有新请求到来，主线程接收之以得到新的连接socket，然后往epoll内核事件表中注册该socket上的读写事件</li><li>如果连接socket上有读写事件发生，主线程从socket上接收数据，并将数据封装成请求对象插入到请求队列中</li><li>所有工作线程睡眠在请求队列上，当有任务到来时，通过竞争（如互斥锁）获得任务的接管权</li></ul><h3 id="29-线程池"><a href="#29-线程池" class="headerlink" title="29.线程池"></a>29.线程池</h3><ul><li>空间换时间,浪费服务器的硬件资源,换取运行效率.</li><li>池是一组资源的集合,这组资源在服务器启动之初就被完全创建好并初始化,这称为静态资源.</li><li>当服务器进入正式运行阶段,开始处理客户请求的时候,如果它需要相关的资源,可以直接从池中获取,无需动态分配.</li><li>当服务器处理完一个客户连接后,可以把相关的资源放回池中,无需执行系统调用释放资源.</li></ul><h3 id="30-epoll的LT和ET"><a href="#30-epoll的LT和ET" class="headerlink" title="30.epoll的LT和ET"></a>30.epoll的LT和ET</h3><ul><li><p>LT（电平触发）：类似<code>select</code>，LT会去遍历在epoll事件表中每个文件描述符，来观察是否有我们感兴趣的事件发生，如果有（触发了该文件描述符上的回调函数），<code>epoll_wait</code>就会以非阻塞的方式返回。若该epoll事件没有被处理完（没有返回<code>EWOULDBLOCK</code>），该事件还会被后续的<code>epoll_wait</code>再次触发。</p></li><li><p>“非阻塞的形式返回”是指<code>epoll_wait</code>在有事件发生时会立即返回，而不是等待其他可能发生的事件。在这种情况下，<code>epoll_wait</code>并不会阻止程序的执行，它会立即提供有关已发生事件的信息。</p><p>在Level-Triggered（LT）模式下，只要文件描述符上的条件满足（例如，数据可读或可写），<code>epoll_wait</code>就会返回。这意味着即使在处理了事件之后，只要条件仍然满足，<code>epoll_wait</code>将继续返回该事件。这就是为什么在处理LT模式下的事件时，你需要完全处理该事件（例如，读取所有可用的数据），以防止<code>epoll_wait</code>不断地返回相同的事件。</p><p>总的来说，”非阻塞的形式返回”意味着<code>epoll_wait</code>会尽快地返回已经就绪的事件，而不会阻止程序的其他部分继续执行。</p></li><li><p>ET（边缘触发）：ET在发现有我们感兴趣的事件发生后，立即返回，并且<code>sleep</code>这一事件的<code>epoll_wait</code>，不管该事件有没有结束。</p></li></ul><p>在使用ET模式时，必须要保证该文件描述符是非阻塞的（确保在没有数据可读时，该文件描述符不会一直阻塞）；并且每次调用<code>read</code>和<code>write</code>的时候都必须等到它们返回<code>EWOULDBLOCK</code>（确保所有数据都已读完或写完）。</p><h3 id="31-epoll阻塞非阻塞和超时时间有关"><a href="#31-epoll阻塞非阻塞和超时时间有关" class="headerlink" title="31.epoll阻塞非阻塞和超时时间有关"></a>31.epoll阻塞非阻塞和超时时间有关</h3><h3 id="32-原子操作和互斥锁的区别"><a href="#32-原子操作和互斥锁的区别" class="headerlink" title="32.原子操作和互斥锁的区别"></a>32.原子操作和互斥锁的区别</h3><p>原子操作（Atomic Operations）和互斥锁（Mutex）是并发编程中常用的两种同步机制，它们有一些区别和不同的应用场景。</p><ol><li><p>原子操作：<br>原子操作是一种不可中断的操作，要么完全执行成功，要么完全不执行。原子操作能够确保在并发环境下对共享数据进行安全访问和更新。在现代计算机架构中，一些基本的操作，如读取、写入内存中的单个字节或字，可以被视为原子操作。原子操作通常是非阻塞的，因为其他线程可以继续执行，而不必等待原子操作完成。</p></li><li><p>互斥锁：<br>互斥锁是一种同步机制，用于保护共享资源，确保同一时间只有一个线程可以访问共享资源。互斥锁提供了一种互斥的机制，当一个线程获得了锁，其他线程就必须等待该线程释放锁之后才能获取锁。互斥锁可以防止多个线程同时访问共享资源，从而避免数据竞争和不一致的结果。</p></li></ol><p>区别：</p><ul><li>原子操作是针对单个操作的，它可以保证操作的原子性，即不会被其他线程中断。而互斥锁是针对一段代码或一段临界区的，它提供了互斥的机制，确保同一时间只有一个线程可以执行被保护的代码段。</li><li>原子操作通常是非阻塞的，不会导致线程的阻塞等待。而互斥锁是一种阻塞同步机制，当一个线程获得锁时，其他线程会被阻塞，直到锁被释放。</li><li>原子操作适用于对共享数据进行简单的读取和写入操作，而互斥锁适用于对共享资源进行复杂的操作或需要确保原子性的代码段。</li><li>原子操作通常比互斥锁的开销更低，因为它们不涉及线程的阻塞和唤醒。但是原子操作的应用场景相对较窄，不能解决所有并发访问问题，而互斥锁更加通用，可以用于任何需要互斥同步的场景。</li></ul><p>在实际编程中，应根据具体情况选择适当的同步机制。如果只需要对共享数据进行简单的读写操作，且并发性要求较高，可以考虑使用原子操作。如果需要对共享资源进行复杂的操作，或者需要保证某一段代码的原子性，</p><p>可以使用互斥锁。</p><ol><li>好的，这些问题涵盖了许多领域。我会尽量简洁清晰地回答它们。</li></ol><h3 id="1-C-中的this指针"><a href="#1-C-中的this指针" class="headerlink" title="1.C++中的this指针"></a>1.<strong>C++中的this指针</strong></h3><p>在C++中，<code>this</code>是一个特殊的指针，它被每一个非静态成员函数隐含地定义。<code>this</code>指针指向调用对象，也就是成员函数操作的对象。这在成员函数内部访问对象的成员变量时非常有用。</p><p>例如，假设有一个类<code>Person</code>，它有一个成员变量<code>name</code>和一个成员函数<code>setName</code>，在<code>setName</code>函数中，<code>this</code>指向调用此函数的对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">    void setName(std::string name) &#123;</span><br><span class="line">        this-&gt;name = name; // &#x27;this&#x27; points to the object that called setName</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    std::string name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-红黑树和AVL树"><a href="#2-红黑树和AVL树" class="headerlink" title="2.红黑树和AVL树"></a>2.<strong>红黑树和AVL树</strong></h3><p>红黑树和AVL树都是自平衡的二叉搜索树。</p><ul><li><strong>红黑树</strong>：每个节点都带有颜色属性，为红色或黑色。红黑树的属性确保了没有一条路径会比其他路径长出两倍以上，因此，红黑树是近似平衡的。红黑树的基本操作（插入、删除、查找）的时间复杂度都是O(log n)。</li><li><strong>AVL树</strong>：AVL树得名于它的发明者G. M. Adelson-Velsky和E. M. Landis。AVL树是高度平衡的：对于每一个节点，它的左子树和右子树的高度最多相差1。这使得AVL树的查询非常快。但是，插入和删除可能需要频繁的旋转来重新平衡树，因此在需要频繁插入和删除的情况下，AVL树可能不如红黑树高效。</li></ul><h3 id="3-红黑树的应用场景"><a href="#3-红黑树的应用场景" class="headerlink" title="3.红黑树的应用场景"></a>3.<strong>红黑树的应用场景</strong></h3><p>红黑树在很多数据结构中都有应用，例如：</p><ul><li><p><strong>关联数组</strong>：红黑树可以用于构建关联数组，例如在C++的<code>std::map</code>和<code>std::set</code>中就使用了红黑树。</p></li><li><p><strong>Linux内核</strong>：Linux内核中的进程调度（Completely Fair Scheduler），以及虚拟内存区域的管理都使用了红黑树。</p></li><li><p>虚拟内存是一种内存管理技术，它使得应用程序看到的地址空间（即虚拟地址空间）与物理内存的实际地址空间分离。在操作系统中，虚拟内存区域（VMAs）是虚拟地址空间的一部分，它们通常由操作系统的内核进行管理。</p><p>红黑树是一种自平衡的二叉查找树，它在许多数据结构和算法中都有应用，包括操作系统的虚拟内存管理。在Linux内核中，红黑树被用于管理VMAs。</p><p>每个VMA都代表一段连续的虚拟地址空间，它有一个起始地址和一个结束地址，以及这段地址空间的一些属性（例如，这段地址空间是否可以读、写或执行，它映射到哪个文件的哪个部分等）。内核用红黑树来存储和查找VMAs，树中的每个节点都代表一个VMA，节点按照其代表的虚拟地址空间的起始地址进行排序。</p><p>使用红黑树的优点是，它可以在对数时间内进行查找、插入和删除操作。这意味着即使虚拟地址空间的数量很大，这些操作的效率也还是很高的。这对于操作系统来说非常重要，因为它需要能够快速地查找和管理VMAs，以便能够有效地处理内存访问请求。</p></li></ul><h3 id="4-网络编程的难点和网络在编程中的作用"><a href="#4-网络编程的难点和网络在编程中的作用" class="headerlink" title="4.网络编程的难点和网络在编程中的作用"></a><strong>4.网络编程的难点和网络在编程中的作用</strong></h3><p>网络编程是编程的一种形式，它使计算机通过网络进行通信。网络编程可以非常复杂，因为它需要处理许多不确定性和变数。这些难点可能包括：</p><ul><li><strong>并发处理</strong>：服务器常常需要同时处理多个连接。这需要使用到多线程、异步IO、事件驱动编程等技术# I’ll continue answering the user’s questions “””</li><li><strong>错误处理</strong>：网络连接可能会中断，数据可能会丢失，这些都需要程序员考虑并处理。</li><li><strong>安全性</strong>：网络编程需要考虑到诸如身份验证、加密和防止攻击等安全问题。</li><li><strong>性能优化</strong>：网络编程需要处理诸如延迟、带宽限制、流量控制等问题，以优化性能。</li></ul><p>网络在编程中的作用非常大。几乎所有的应用程序，无论是web应用、移动应用，还是桌面应用，都在某种程度上依赖于网络。网络使得分布式系统成为可能，使得应用程序可以在全球范围内进行通信和交互。</p><h3 id="5-二叉树输出最底层、最左节点的值"><a href="#5-二叉树输出最底层、最左节点的值" class="headerlink" title="5.二叉树输出最底层、最左节点的值"></a>5.<strong>二叉树输出最底层、最左节点的值</strong></h3><p>这个问题可以通过层次遍历（广度优先搜索）的方式来解决。我们可以遍历整个树，每次都记录下每一层的第一个（最左边）的节点。最后一个记录下的节点就是最底层最左边的节点。</p><p>下面是一个用C++实现的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">struct TreeNode &#123;</span><br><span class="line">    int val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int findBottomLeftValue(TreeNode* root) &#123;</span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.push(root);</span><br><span class="line">    int result = root-&gt;val;</span><br><span class="line"></span><br><span class="line">while (!q.empty()) &#123;</span><br><span class="line">    int size = q.size();</span><br><span class="line">    for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">        TreeNode* node = q.front(); q.pop();</span><br><span class="line">        if (i == 0) result = node-&gt;val; // record the first node of each level</span><br><span class="line">        if (node-&gt;left) q.push(node-&gt;left);</span><br><span class="line">        if (node-&gt;right) q.push(node-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Linux系统和嵌入式系统的相似之处"><a href="#Linux系统和嵌入式系统的相似之处" class="headerlink" title="Linux系统和嵌入式系统的相似之处"></a><strong>Linux系统和嵌入式系统的相似之处</strong></h3><p>Linux系统和嵌入式系统都是操作系统，它们都负责管理和协调硬件资源，提供运行应用程序的环境。具体来说，它们都有进程管理、内存管理、文件系统等基本功能。而且，Linux系统本身就被广泛应用于嵌入式系统中，因为Linux系统是开源的，可以根据嵌入式系统的特殊需求进行定制和优化。</p><h3 id="线程和进程的区别和联系"><a href="#线程和进程的区别和联系" class="headerlink" title="线程和进程的区别和联系"></a><strong>线程和进程的区别和联系</strong></h3><p>进程是操作系统分配资源的基本单位，它包括一个执行流（即程序计数器），一个私有的地址空间，以及一组系统资源（如打开的文件和信号处理例程）。线程则是操作系统调度的基本单位，它包括一个执行流和一些寄存器的值，但它共享其所在进程的地址空间和资源。</p><p>进程可以拥有一个或多个线程，同一个进程内的多个线程可以并发执行，并共享进程的资源。线程之间的通信比进程之间的通信更高效，因为它们共享相同的地址空间。</p><h3 id="线程的通信方式"><a href="#线程的通信方式" class="headerlink" title="线程的通信方式"></a><strong>线程的通信方式</strong></h3><p>线程之间的通信方式有很多种，以下是一些常见的方式：</p><ul><li><p><strong>共享内存</strong>：线程之间可以通过读写同一块内存来进行通信。这是最快的通信方式，但需要注意同步问题，以避免数据竞争。</p></li><li><p><strong>信号量</strong>：信号量是一种同步机制，可以用于保护共享资源，也可以用于线程之间的通信。</p></li><li><p><strong>条件变量</strong>：条件变量可以让一个线程在某个条件满足时得到通知，从而进行相应的处理。</p></li><li><p><strong>消息队列</strong>：线程可以将消息发送到消息队列，其他线程可以从队列中取出消息。这是一种更高层次的通信方式，可以避免低级的同步问题。</p></li></ul><h3 id="TCP和UDP区别，TCP通信的过程"><a href="#TCP和UDP区别，TCP通信的过程" class="headerlink" title="TCP和UDP区别，TCP通信的过程"></a><strong>TCP和UDP区别，TCP通信的过程</strong></h3><p>TCP（Transmission Control Protocol，传输控制协议）和UDP（User Datagram Protocol，用户数据报协议）都是网络传输层的协议，但它们有一些重要的区别：</p><ul><li><p><strong>可靠性</strong>：TCP提供了可靠的数据传输，它会对丢失的数据包进行重传，对乱序的数据包进行排序。而UDP则不提供这些功能，它只是简单地将数据包发送出去。</p></li><li><p><strong>连接</strong>：TCP是面向连接的协议，它的通信需要先建立连接，然后再进行数据传输。UDP则是无连接的协议，它的通信不需要建立连接。</p></li><li><p><strong>流控制和拥塞控制</strong>：TCP有流控</p></li></ul><p>制和拥塞控制机制，可以根据网络的状况调整数据的发送速率。UDP则没有这些机制。</p><p>TCP的通信过程一般包括三个步骤：连接建立（三次握手）、数据传输和连接释放（四次挥手）。</p><h3 id="三次握手过程"><a href="#三次握手过程" class="headerlink" title="三次握手过程"></a><strong>三次握手过程</strong></h3><p><img src="C:\Users\26640\AppData\Roaming\Typora\typora-user-images\image-20230520213819922.png" alt="image-20230520213819922"></p><p>三次握手是TCP建立连接的过程，具体步骤如下：</p><ul><li><p>第一次握手：客户端发送一个SYN包（同步序列编号）到服务器，请求建立连接。</p></li><li><p>第二次握手：服务器收到SYN包后，发送一个SYN-ACK包（同步应答）到客户端，表示同意建立连接。</p></li><li><p>第三次握手：客户端收到SYN-ACK包后，发送一个ACK包（确认）到服务器，完成连接的建立。</p></li></ul><h3 id="四次挥手时服务器和客户端哪个先关闭"><a href="#四次挥手时服务器和客户端哪个先关闭" class="headerlink" title="四次挥手时服务器和客户端哪个先关闭"></a><strong>四次挥手时服务器和客户端哪个先关闭</strong></h3><p><img src="C:\Users\26640\AppData\Roaming\Typora\typora-user-images\image-20230520213921462.png" alt="image-20230520213921462"></p><p>在TCP协议的连接终止过程中，也就是所谓的”四次挥手”（Four-Way Handshake）过程中，任何一方都可以首先发起关闭连接的请求。这就意味着，无论是客户端（Client）还是服务器（Server），都可以先关闭。</p><p>以下是一个简单的四次挥手过程：</p><ol><li><p>假设客户端决定关闭连接。客户端发送一个FIN包给服务器，表示客户端已经停止了数据发送。但是，客户端仍然可以接收数据。</p></li><li><p>服务器收到这个FIN包后，发送一个ACK包给客户端，表示它已经接收到了FIN包。</p></li><li><p>当服务器已经发送完所有数据后，也会发送一个FIN包给客户端，告诉客户端，服务器端也已经没有数据要发送了。</p></li><li><p>客户端收到这个FIN包后，也发送一个ACK包给服务器，告诉服务器，客户端已经接收到了FIN包。</p></li></ol><p>注意，虽然在这个例子中，是客户端先发起的关闭连接请求，但实际上，服务器也可以首先发起关闭连接的请求。</p><p>在这个过程中，关闭一个连接需要发送和接收四个包，因此被称为”四次挥手”。在TCP的四次挥手过程中，任何一方都可以先发起关闭连接的请求。通常来说，谁先结束使用连接，谁就可以先发起关闭连接的请求。</p><h3 id="为什么要有timewait"><a href="#为什么要有timewait" class="headerlink" title="为什么要有timewait"></a>为什么要有timewait</h3><p>TCP的TIME_WAIT状态是连接关闭过程中的一个重要步骤，它的存在有几个主要的原因：</p><ol><li><p><strong>可靠的终止TCP连接</strong>：在TCP四次挥手的过程中，最后一个ACK包是由关闭连接的发起方（可能是客户端，也可能是服务器）发送的。如果这个ACK包在网络中丢失，那么另一方（在这个例子中是接收方）将重发FIN包。TIME_WAIT状态就是为了处理这种情况：如果发起方收到重发的FIN包，它可以再次发送ACK包。如果没有TIME_WAIT状态，连接可能在另一方还期望得到ACK包的情况下被关闭，这将导致不可预知的结果。</p></li><li><p><strong>防止旧的重复包在新的连接中被误认为是有效的数据</strong>：TCP通过使用序列号来标识每一个数据包。序列号在每个新的连接中从零开始，然后每发送一个数据包，序列号就增加。如果一个连接很快地关闭然后立即重新打开，有可能新连接的序列号会与旧连接中延迟的数据包的序列号相同。这种情况下，旧的数据包可能被误认为是新连接中的有效数据。TIME_WAIT状态可以防止这种情况的发生，因为它强制连接在一段时间内保持关闭状态，这段时间足够让网络中的所有旧的重复包被丢弃。</p></li></ol><p>在实际应用中，TIME_WAIT状态的持续时间通常设置为4分钟，这是为了保证在网络中的所有数据包都有足够的时间被正确处理。然而，这个时间可以根据网络的具体条件进行调整。</p><h3 id="视频连线用的是协议？为什么"><a href="#视频连线用的是协议？为什么" class="headerlink" title="视频连线用的是协议？为什么"></a>视频连线用的是协议？为什么</h3><p>视频通话大多使用的是实时传输协议（RTP），以及其控制协议RTCP。RTP是为实时数据包提供端到端传输服务的网络协议，适合用于多媒体应用（如电话会议、视频会议、网络电视），而RTCP则用于监视数据传输质量，提供反馈信息，以便于维护服务质量。这些协议通常<strong>基于UDP，因为UDP的延迟小，适合用于实时通信</strong>。</p><p>但现在具体使用的协议，以及为什么使用这个协议，可能需要查询最新的信息。</p><h3 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h3><p>管道（pipe）是一种进程间通信的方式，它可以在同一个系统上的两个进程之间传输数据。管道的实现相对简单，因为它只需要操作系统支持，而不需要网络或者文件系统的支持。但管道的使用还需要注意一些问题，比如数据的同步和阻塞问题。</p><p>管道（pipe）是一种基于Unix和类Unix系统（如Linux）的进程间通信（Inter-Process Communication, IPC）机制。它允许一个进程将它的输出直接发送到另一个进程的输入。</p><p>管道有两种类型：匿名管道和命名管道。</p><ol><li><p><strong>匿名管道</strong>：这种管道只能用于具有父子关系的进程间的通信（因为它们在创建后只存在于创建它们的进程的地址空间中）。父进程创建管道，然后通过fork()系统调用创建子进程。这样，父子进程就可以通过这个管道进行通信。通常，父进程写入管道，子进程从管道读取，或者反过来。</p></li><li><p><strong>命名管道（也称为FIFO）</strong>：这种管道可以用于任何两个运行在同一台机器上的进程间的通信。命名管道在文件系统中有一个名字，任何知道这个名字的进程都可以向这个管道写入或从这个管道读取。</p></li></ol><p>管道通常用于”管道”命令，这是Unix和类Unix系统的一个强大特性。例如，你可以使用一个命令（如<code>ls</code>）来生成一些输出，然后使用管道将这个输出传递给另一个命令（如<code>sort</code>）进行进一步的处理。这种方式可以将多个简单的命令组合成一个强大的工具。</p><p>这是一个简单的C语言的匿名管道示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> fd[<span class="number">2</span>];</span><br><span class="line">    <span class="type">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    pipe(fd); <span class="comment">// 创建管道</span></span><br><span class="line"></span><br><span class="line">    pid = fork(); <span class="comment">// 创建子进程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 子进程</span></span><br><span class="line">        close(fd[<span class="number">1</span>]); <span class="comment">// 关闭写端</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">20</span>];</span><br><span class="line">        read(fd[<span class="number">0</span>], buf, <span class="keyword">sizeof</span>(buf)); <span class="comment">// 从管道读取数据</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child process received: %s\n&quot;</span>, buf);</span><br><span class="line">        close(fd[<span class="number">0</span>]); <span class="comment">// 关闭读端</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 父进程</span></span><br><span class="line">        close(fd[<span class="number">0</span>]); <span class="comment">// 关闭读端</span></span><br><span class="line">        <span class="type">char</span> *str = <span class="string">&quot;hello, child!&quot;</span>;</span><br><span class="line">        write(fd[<span class="number">1</span>], str, <span class="keyword">sizeof</span>(str)); <span class="comment">// 向管道写入数据</span></span><br><span class="line">        close(fd[<span class="number">1</span>]); <span class="comment">// 关闭写端</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个示例中，父进程创建了一个管道，然后fork了一个子进程。父进程向管道写入了一些数据，子进程从管道读取了这些数据。</p><p>Linux操作系统中的管道（pipe）是一种进程间通信（IPC）的机制，它允许一个进程的输出被作为另一个进程的输入。Linux中的管道主要有两种：匿名管道和命名管道（FIFO）。</p><ol><li><strong>匿名管道</strong>：匿名管道主要用于父子进程之间的通信。父进程创建一个管道，然后分叉（fork）出一个子进程，然后父子进程就可以通过这个管道进行通信。这种管道是单向的，通常情况下，一个进程写数据到管道，另一个进程从管道读数据。</li></ol><p>下面是在bash shell中使用管道的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> | <span class="built_in">sort</span></span><br></pre></td></tr></table></figure><p>在这个例子中，”ls”命令的输出被作为”sort”命令的输入。</p><ol start="2"><li><strong>命名管道（FIFO）</strong>：命名管道与匿名管道类似，但它们在文件系统中有一个路径名。通过这个名字，不相关的进程可以通过命名管道进行通信。命名管道使用mknod或mkfifo命令创建。</li></ol><p>以下是创建和使用命名管道的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkfifo</span> my_pipe    <span class="comment"># 创建一个命名管道</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span> &gt; my_pipe  <span class="comment"># 在一个shell中写入数据到管道</span></span><br><span class="line"><span class="built_in">cat</span> &lt; my_pipe  <span class="comment"># 在另一个shell中从管道读数据</span></span><br></pre></td></tr></table></figure><p>在这个例子中，数据被写入命名管道”my_pipe”，然后从”my_pipe”读出。</p><p>在Linux编程中，可以使用pipe（）系统调用创建匿名管道，使用mkfifo（）系统调用创建命名管道，然后通过读写文件描述符来读写管道。</p><h3 id="数组和链表有什么区别？"><a href="#数组和链表有什么区别？" class="headerlink" title="数组和链表有什么区别？"></a><strong>数组和链表有什么区别？</strong></h3><p>数组和链表都是常见的数据结构，它们有以下</p><p>一些主要的区别：</p><ul><li><p><strong>内存分配</strong>：数组是连续的内存空间，而链表则是由一系列分散的节点组成，每个节点包含数据和指向下一个节点的指针。</p></li><li><p><strong>插入和删除</strong>：在数组中插入和删除元素需要移动其他元素，所以这些操作的时间复杂性是O(n)。而在链表中插入和删除元素只需要改变一些指针，所以这些操作的时间复杂性是O(1)。</p></li><li><p><strong>访问</strong>：数组可以通过索引直接访问任何元素，所以访问操作的时间复杂性是O(1)。而链表只能从头开始遍历，所以访问操作的时间复杂性是O(n)。</p></li></ul><h3 id="用过哪些数据结构？说说队和栈"><a href="#用过哪些数据结构？说说队和栈" class="headerlink" title="用过哪些数据结构？说说队和栈"></a>用过哪些数据结构？说说队和栈</h3><p>数据结构是在计算机科学中存储、组织数据的一种方式，以便有效地进行插入、删除和查找等操作。以下是一些常见的数据结构：</p><ol><li><p><strong>数组（Array）</strong>：数组是最基本的数据结构，它可以在连续的内存空间中存储固定数量的元素。数组的优点是可以通过索引在常量时间内访问任何元素，但缺点是大小固定，不能动态地添加或删除元素。</p></li><li><p><strong>链表（Linked List）</strong>：链表由一系列节点组成，每个节点包含数据和指向下一个节点的指针。链表的优点是可以在任何位置插入或删除元素，但缺点是查找特定元素需要遍历链表。</p></li><li><p><strong>栈（Stack）</strong>：栈是一种后入先出（LIFO）的数据结构，可以在其顶部添加和移除元素。栈常用于实现递归算法。</p></li><li><p><strong>队列（Queue）</strong>：队列是一种先入先出（FIFO）的数据结构，添加元素（入队）在一端进行，移除元素（出队）在另一端进行。队列常用于实现广度优先搜索等算法。</p></li><li><p><strong>哈希表（Hash Table）</strong>：哈希表是一种使用哈希函数将键映射到值的数据结构，可以在平均情况下在常量时间内进行插入、查找和删除操作。</p></li><li><p><strong>树（Tree）</strong>：树是一种层次的数据结构，由根节点和多个子树组成。常见的树包括二叉搜索树、AVL树、红黑树等。</p></li><li><p><strong>堆（Heap）</strong>：堆是一种特殊的树，它满足堆属性：每个节点的值都大于或等于（最大堆）或小于或等于（最小堆）其子节点的值。堆常用于实现优先队列。</p></li><li><p><strong>图（Graph）</strong>：图由节点（或顶点）和连接节点的边组成。图可以是无向的（边没有方向）或有向的（边有方向）。图常用于表示和处理诸如网络、路由等问题。</p></li></ol><p>以上这些数据结构都有各自的优缺点，适用于不同的情况。在实际使用中，选择哪种数据结构取决于你需要解决的具体问题。</p><p>栈和队列是两种常见的数据结构：</p><ul><li><p><strong>栈</strong>：栈是一种后进先出（LIFO）的数据结构，可以把它想象成一个堆叠的盘子，你只能看到和操作最上面的盘子。</p></li><li><p><strong>队列</strong>：队列是一种先进先出（FIFO）的数据结构，可以把它想象成一个排队的人群，最先进入队列的人最先离开队列。</p></li></ul><h3 id="虚拟内存空间"><a href="#虚拟内存空间" class="headerlink" title="虚拟内存空间"></a><strong>虚拟内存空间</strong></h3><p>虚拟内存是一种内存管理技术，它使得应用程序看到的地址空间（即虚拟地址空间）与物理内存的实际地址空间分离。虚拟内存空间通常比物理内存空间大，这是通过将虚拟地址空间的一部分映射到磁盘上的交换空间（swap space）实现的。</p><p>虚拟内存有几个主要的优点：</p><ul><li><p><strong>内存保护</strong>：每个进程有自己的虚拟地址空间，不能访问其他进程的地址空间，这提供了一种内存保护机制。</p></li><li><p><strong>内存抽象</strong>：虚拟内存为每个进程提供了一致的地址空间抽象，使得编程更简单。</p></li><li><p><strong>内存管理</strong>：虚拟内存使得操作系统可以更灵活地管理内存，例如通过需求分页（demand paging）和内存交换（memory swapping）技术。</p></li></ul><h3 id="字符串逆转"><a href="#字符串逆转" class="headerlink" title="字符串逆转"></a><strong>字符串逆转</strong></h3><p>在C++中，可以使用标准库中的<code>std::reverse</code>函数来逆转字符串。以下是一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">reverseString</span><span class="params">(std::string s)</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s</span><br><span class="line"></span><br><span class="line">.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码首先包含了<algorithm>和<string>两个头文件，然后定义了一个函数<code>reverseString</code>，这个函数接受一个字符串<code>s</code>作为参数，然后使用<code>std::reverse</code>函数来逆转<code>s</code>，最后返回逆转后的字符串。</p><h3 id="程序的编译步骤？"><a href="#程序的编译步骤？" class="headerlink" title="程序的编译步骤？"></a><strong>程序的编译步骤？</strong></h3><p>程序的编译一般包括以下四个步骤：</p><ol><li><p><strong>预处理（Preprocessing）</strong>：在这个步骤中，编译器处理源代码中的预处理指令，如#include和#define。预处理器将#include指令指向的文件内容插入到源代码中，将#define定义的宏进行替换。</p></li><li><p><strong>编译（Compilation）</strong>：在这个步骤中，编译器将预处理后的源代码转化为汇编代码。编译器在这个过程中会检查代码的语法错误，进行优化，以及生成符号表等。</p></li><li><p><strong>汇编（Assembly）</strong>：在这个步骤中，汇编器将汇编代码转化为机器代码，生成目标文件。机器代码是二进制代码，可以直接被计算机硬件执行。</p></li><li><p><strong>链接（Linking）</strong>：在这个步骤中，链接器将一个或多个目标文件以及库文件链接成一个可执行文件。链接器在这个过程中会解析符号引用，将代码和数据合并到相应的段中。</p></li></ol><p>以上是一个常见的编译过程，具体的过程可能会因编译器的不同而有所变化。</p><p>我很抱歉，我们的网络搜索工具出现了一些问题，我将尽力直接回答您的问题。</p><h3 id="实时操作系统（RTOS）："><a href="#实时操作系统（RTOS）：" class="headerlink" title="实时操作系统（RTOS）："></a><strong>实时操作系统（RTOS）</strong>：</h3><p>RTOS是专门为实时应用设计的操作系统，它可以在特定（通常是非常短的）时间内预测确保任务完成。这使得实时系统非常适合在时间约束严格的环境中运行，例如航天飞行器、医疗设备、嵌入式系统等。RTOS的关键特性包括最小延迟任务切换、实时调度和优先级调度。</p><p>实时操作系统（Real-Time Operating System，RTOS）是一种能够在特定的时间内保证完成特定任务的操作系统。RTOS通常用于嵌入式系统和实时系统中，如飞行控制系统、医疗设备、工业控制系统等。RTOS的主要特点如下：</p><ol><li><p><strong>实时性</strong>：RTOS能够在确定的时间内响应外部事件，这是它与普通操作系统最大的区别。实时性包括硬实时性和软实时性。硬实时系统必须在预定的时间内完成任务，否则可能会导致系统崩溃或生命危险。软实时系统则对完成任务的时间要求不那么严格，如果偶尔超时，系统可以继续运行，只是性能会有所下降。</p></li><li><p><strong>多任务和任务调度</strong>：RTOS支持多任务并发执行，能够根据任务的优先级、时间约束等进行任务调度。RTOS的任务调度算法通常包括优先级调度、循环执行调度、最早截止时间优先调度等。</p></li><li><p><strong>可预测性</strong>：RTOS必须具有可预测性，即在任何情况下，系统的行为都是可以预知的。</p></li><li><p><strong>小型化</strong>：由于RTOS通常用于资源有限的嵌入式系统中，因此RTOS通常设计得非常小型，以减少资源的占用。</p></li><li><p><strong>稳定性和健壮性</strong>：由于RTOS通常用于关键任务中，因此必须具有高度的稳定性和健壮性，能够在各种异常情况下保证系统的正常运行。</p></li></ol><p>RTOS的常见应用包括飞行控制系统、汽车电子系统、机器人系统、工业控制系统、医疗设备等。在这些系统中，对时间的要求非常严格，不能容忍任务的延迟或失效，因此需要使用RTOS来保证系统的实时性和可靠性。</p><p>在RTOS中，任务通常被分为不同的优先级，高优先级的任务可以抢占低优先级的任务。RTOS还提供了各种同步机制，如互斥锁、信号量、事件等，用于解决任务之间的同步和通信问题。</p><p>RTOS的主要挑战包括如何在有限的资源下满足实时性的要求，如何设计有效的任务调度算法和同步机制，如何处理各种异常情况等。</p><h4 id="多任务调度："><a href="#多任务调度：" class="headerlink" title="多任务调度："></a><strong>多任务调度</strong>：</h4><p>多任务调度是操作系统的一个重要部分，它允许多个任务在一个处理器上并发执行。RTOS中的多任务调度通常是优先级调度，即每个任务都有一个优先级，调度器会选择优先级最高的任务执行。在抢占式调度策略中，如果一个更高优先级的任务就绪（例如，等待的I&#x2F;O操作完成），那么RTOS将保存当前任务的状态，暂停它，并开始执行更高优先级的任务。这种快速响应是RTOS非常适合实时应用的一个原因。</p><h4 id="互斥信号量（Mutex-Semaphore）："><a href="#互斥信号量（Mutex-Semaphore）：" class="headerlink" title="互斥信号量（Mutex Semaphore）："></a><strong>互斥信号量（Mutex Semaphore）</strong>：</h4><p>在并发编程中，互斥信号量是一种用于控制多个任务访问共享资源的工具。如果一个任务正在使用一个共享资源（例如，一个内存区域或I&#x2F;O端口），它会锁定一个互斥信号量。这将阻止其他任务访问该资源，直到第一个任务完成其工作并解锁互斥信号量。互斥信号量是一种保护共享资源免受并发任务干扰的重要方式，它们是确保数据一致性和防止竞态条件的关键工具。</p><p>在RTOS中，互斥信号量的使用非常重要，因为它们可以帮助我们在并发任务之间同步对共享资源的访问，这对于实时系统来说是至关重要的，因为在这些系统中，任务通常需要在硬实时约束下执行。</p><p>希望这能帮助您更好地理解RTOS、多任务调度和互斥信号量。如果您有任何其他问题，或者需要更深入的解释，请随时告诉我。</p><h3 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP&#x2F;IP协议"></a>TCP&#x2F;IP协议</h3><p>TCP&#x2F;IP（传输控制协议&#x2F;网络协议）是一种网络通信模型，也是一套用于互联网及其他网络的协议。它由一组不同的协议组成，包括TCP（传输控制协议）、IP（网络协议）、UDP（用户数据报协议）、ICMP（互联网控制消息协议）等等。</p><p>TCP&#x2F;IP模型通常被分为四个层次，每个层次都有其特定的功能：</p><ol><li><p><strong>网络接口层</strong>：这一层处理所有硬件级的细节，包括物理设备、驱动、网卡等等。这一层的主要任务是通过网络发送和接收数据包。</p></li><li><p><strong>网络层</strong>：这一层负责数据包的路由和转发。它使用IP协议（IPv4或IPv6）来为每个设备分配一个唯一的地址，并确定如何将数据包从源地址发送到目标地址。ICMP协议也在这一层工作，用于传送网络相关的控制消息，如错误报告或回显请求和回显应答（用于ping命令）。</p></li><li><p><strong>传输层</strong>：这一层提供了端到端的通信服务。在这一层，TCP协议提供了一种可靠的、面向连接的服务，它确保数据在网络中正确无误地传输，通过使用确认、重传和拥塞控制机制来处理网络中可能出现的问题。而UDP协议则提供了一种无连接的服务，它发送数据时不保证数据的可靠传输，因此开销更小，速度更快。</p></li><li><p><strong>应用层</strong>：这一层包含了所有针对特定应用的协议，如HTTP（用于网页）、SMTP（用于电子邮件）、FTP（用于文件传输）等等。这些协议定义了应用程序如何通过网络进行交互和数据交换。</p></li></ol><p>值得注意的是，虽然TCP&#x2F;IP模型只有四层，但它通常被映射到OSI（开放系统互联）模型的七层，这是因为OSI模型提供了更详细的网络通信的视图。</p><h3 id="C和C-的区别"><a href="#C和C-的区别" class="headerlink" title="C和C++的区别"></a>C和C++的区别</h3><p>C和C++都是常用的编程语言，它们在语法和功能上有很多相似之处。实际上，C++最初是作为C语言的一个超集设计的，也就是说，大部分合法的C程序（除了一些例外）也是合法的C++程序。然而，C++在C的基础上添加了许多新的特性和功能，使其更适合用于大型软件和复杂系统的开发。以下是C和C++之间的一些主要区别：</p><ol><li><p><strong>面向对象编程</strong>：C++支持面向对象编程（OOP），这是一种编程范式，它使用类和对象来创建更清晰、更易于理解和维护的代码。在OOP中，数据和操作数据的函数被封装在对象中，可以使用继承、封装和多态性等特性。而C语言不支持OOP。</p></li><li><p><strong>标准模板库（STL）</strong>：C++提供了一个强大的标准模板库，它包含了各种预定义的类和函数，用于处理像链表、队列、栈、哈希表和树这样的常见数据结构，以及各种常用算法。而C语言没有提供类似的库。</p></li><li><p><strong>异常处理</strong>：C++支持异常处理，这是一种处理运行时错误的机制。在C++中，可以使用try、catch和throw关键字来捕获和处理异常。而C语言不支持异常处理，通常使用函数返回值和全局变量（如errno）来表示错误。</p></li><li><p><strong>命名空间</strong>：C++支持命名空间，这是一种防止名称冲突的机制。在C++中，可以使用namespace关键字来创建命名空间。C语言没有命名空间的概念。</p></li><li><p><strong>函数重载</strong>：C++支持函数重载，这意味着可以使用相同的函数名来定义多个函数，只要它们的参数列表不同即可。这使得代码更加清晰和易于理解。而C语言不支持函数重载。</p></li><li><p><strong>类型安全</strong>：C++比C语言更具类型安全。例如，C++禁止隐式转换来初始化变量或在表达式中混合不同类型的数据，除非使用显式类型转换。</p></li></ol><p>总的来说，C++相比C语言更加强大和灵活，但也更加复杂。选择使用哪种语言取决于具体的项目需求和开发者的经验。</p><h3 id="手写字符串拷贝函数"><a href="#手写字符串拷贝函数" class="headerlink" title="手写字符串拷贝函数"></a>手写字符串拷贝函数</h3><p>字符串拷贝函数的实现取决于具体的编程语言。假设你是在问C或C++，下面是一个简单的字符串拷贝函数的实现：</p><p>在C语言中，你可能会使用字符指针来实现一个字符串拷贝函数，如下所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_strcpy</span><span class="params">(<span class="type">char</span>* dest, <span class="type">const</span> <span class="type">char</span>* src)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(*src) &#123;</span><br><span class="line">        *dest = *src;</span><br><span class="line">        src++;</span><br><span class="line">        dest++;</span><br><span class="line">    &#125;</span><br><span class="line">    *dest = <span class="string">&#x27;\0&#x27;</span>;  <span class="comment">// 添加字符串结束符</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> src[] = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">    <span class="type">char</span> dest[<span class="number">50</span>];</span><br><span class="line">    my_strcpy(dest, src);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, dest);  <span class="comment">// 输出：Hello, world!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在C++中，你可以使用字符串对象（std::string）来实现一个字符串拷贝函数，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">my_strcpy</span><span class="params">(<span class="type">const</span> std::string&amp; src)</span> </span>&#123;</span><br><span class="line">    std::string dest = src;</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string src = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">    std::string dest = <span class="built_in">my_strcpy</span>(src);</span><br><span class="line">    std::cout &lt;&lt; dest &lt;&lt; std::endl;  <span class="comment">// 输出：Hello, world!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请注意，这些函数都没有进行错误检查，例如确认目标字符串有足够的空间来保存源字符串。在实际编程中，你应该始终检查并处理可能的错误情况。</p><h3 id="linux多线程通信"><a href="#linux多线程通信" class="headerlink" title="linux多线程通信"></a>linux多线程通信</h3><p>在Linux环境下，多线程程序通常通过以下几种方式进行通信：</p><ol><li><p><strong>共享内存</strong>：在同一进程的不同线程之间，因为它们共享同一地址空间，所以可以通过共享内存进行通信。这是最快的通信方式，但需要注意的是，必须使用适当的同步机制（如互斥锁或信号量）来防止数据竞争。</p></li><li><p><strong>互斥锁（Mutex）</strong>：互斥锁是一种同步机制，用于保护共享资源不被多个线程同时访问。当一个线程正在使用一个共享资源时，它会“锁定”该资源，其他想要访问该资源的线程必须等待，直到该线程释放该资源。</p></li><li><p><strong>条件变量</strong>：条件变量是一种允许线程等待某个条件的同步机制。例如，一个线程可能正在等待一个任务队列非空，当其他线程添加一个任务到队列时，它可以使用条件变量来通知等待线程。</p></li><li><p><strong>信号量（Semaphore）</strong>：信号量是一种更通用的同步机制，可以用来控制对共享资源的访问，也可以用来在线程之间发送信号。</p></li><li><p><strong>消息队列</strong>：消息队列允许线程将消息发送到一个队列，其他线程可以从队列中读取消息。虽然这种方法在进程间通信（IPC）中更常见，但也可以用于线程间通信。</p></li></ol><p>以上是一些常见的线程间通信方式，选择哪种方式取决于你的具体需求。有些方法更适合于大量数据的传输（如共享内存），有些方法则更适合于事件通知（如条件变量和信号量）。</p><h3 id="多线程编程GDB调试"><a href="#多线程编程GDB调试" class="headerlink" title="多线程编程GDB调试"></a>多线程编程GDB调试</h3><p>在多线程编程中，通常使用 gdb (GNU Debugger) 进行调试。gdb 提供了一系列的命令来查看和切换线程。以下是一些常用的 gdb 命令：</p><ol><li><p><code>info threads</code>：此命令将列出所有的线程。每个线程都有一个唯一的标识符，你可以使用这个标识符来切换到特定的线程。</p></li><li><p><code>thread thread-id</code>：此命令用于切换到指定的线程。你需要将 <code>thread-id</code> 替换为你要切换到的线程的标识符。</p></li><li><p><code>thread apply thread-id command</code>：此命令将在指定的线程中执行指定的命令。你可以将 <code>thread-id</code> 替换为你要执行命令的线程的标识符，将 <code>command</code> 替换为你要执行的 gdb 命令。</p></li><li><p><code>thread apply all command</code>：此命令将在所有线程中执行指定的命令。你可以将 <code>command</code> 替换为你要执行的 gdb 命令。</p></li></ol><p>这些命令提供了在 gdb 中查看和切换线程的基本功能。然而，请注意，gdb 的功能非常强大，提供了许多其他的高级功能和命令。如果你想深入了解 gdb 的使用，我建议你查阅 gdb 的官方文档或相关的教程。</p><h3 id="tcp和udp的区别"><a href="#tcp和udp的区别" class="headerlink" title="tcp和udp的区别"></a>tcp和udp的区别</h3><p>TCP（传输控制协议）和UDP（用户数据报协议）都是互联网协议（IP）的核心协议，用于在网络上发送数据。然而，它们在设计和行为上有很大的不同：</p><ol><li><p><strong>连接的有无</strong>：TCP是一种面向连接的协议，这意味着在数据传输之前，发送者和接收者必须先建立一个连接。UDP则是无连接的，发送者可以直接发送数据，无需先建立连接。</p></li><li><p><strong>数据的可靠性</strong>：TCP提供了数据的可靠传输。这意味着如果数据在传输过程中丢失或损坏，TCP将负责重发数据，直到接收者正确地接收到所有数据。UDP则不提供数据的可靠传输，如果数据在传输过程中丢失或损坏，UDP不会尝试重发。</p></li><li><p><strong>数据的顺序</strong>：TCP保证数据的顺序传输，即数据将按照发送的顺序被接收。UDP则不保证数据的顺序，数据可能会以任何顺序到达接收者。</p></li><li><p><strong>速度和效率</strong>：由于UDP省略了许多TCP所具有的错误检测和顺序保证机制，所以UDP通常比TCP更快，资源开销更小。因此，对于需要快速传输并且可以容忍一定数据丢失的应用（如视频流或在线游戏），通常使用UDP。</p></li><li><p><strong>流控制和拥塞控制</strong>：TCP有流控制和拥塞控制机制，能够避免网络拥塞，而UDP则没有这些机制。</p></li><li><p><strong>头部开销</strong>：TCP的头部开销更大，至少需要20字节，而UDP的头部开销较小，只需要8字节。</p></li></ol><p>选择TCP还是UDP取决于你的应用需求。如果需要可靠性和顺序保证，应选择TCP。如果需要速度和效率，应选择UDP。</p><h3 id="一、字节对齐"><a href="#一、字节对齐" class="headerlink" title="一、字节对齐"></a>一、字节对齐</h3><p>字节对齐的概念<br>字节对齐后字段的偏移大小<br>字节对齐的原因</p><p>一、字节对齐的概念：<br>字节对齐（Byte Alignment）是指在内存中分配数据时，按照特定规则将数据存放在内存中的起始地址，以满足硬件或操作系统的要求。它确保数据的存储和访问的效率，并且有助于避免因不正确对齐而引起的性能问题和错误。</p><p>二、字节对齐后字段的偏移大小：<br>在进行字节对齐时，字段的偏移大小是指该字段在结构体或类中的起始位置相对于结构体或类起始位置的字节偏移量。</p><p>偏移大小的计算方式可以根据编译器和特定的对齐规则而有所不同。在一般情况下，偏移大小取决于字段的类型和对齐规则。通常情况下，字段的偏移大小应为其自身大小（以字节为单位）的整数倍。</p><p>三、字节对齐的原因：</p><ol><li><p>性能优化：对齐的数据访问通常更高效。例如，某些架构要求特定类型的数据在特定地址上的读取或写入操作，如果数据未对齐，将导致额外的开销和处理器的性能下降。</p></li><li><p>平台兼容性：不同的硬件和操作系统可能对字节对齐有不同的要求。通过进行字节对齐，可以确保在不同平台上编译的代码的一致性和可移植性。</p></li><li><p>数据结构的完整性：某些硬件对于特定类型的数据访问要求其地址是对齐的，否则可能导致数据被截断或无法正确解析。</p></li></ol><p>总之，字节对齐是为了保证数据的访问效率和数据的完整性，以满足硬件和操作系统的要求。通过适当的字节对齐，可以提高程序的性能和可移植性。</p><h3 id="二、字节序"><a href="#二、字节序" class="headerlink" title="二、字节序"></a>二、字节序</h3><p>大小端<br>网络&#x2F;主机序<br>如何判断当前主机序是大端序还是小端序</p><p>字节序是计算机科学中的一个重要概念，主要用于表示在存储器中如何存储多字节数据的顺序。通常有两种方式：大端字节序（Big-Endian）和小端字节序（Little-Endian）。</p><p>大端字节序（Big-Endian）：最重要的字节在最前面。比如一个四字节的数0x12345678，在内存中的存储方式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">地址 0x100: 12</span><br><span class="line">地址 0x101: 34</span><br><span class="line">地址 0x102: 56</span><br><span class="line">地址 0x103: 78</span><br></pre></td></tr></table></figure><p>小端字节序（Little-Endian）：最重要的字节在最后面。同样的例子，在内存中的存储方式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">地址 0x100: 78</span><br><span class="line">地址 0x101: 56</span><br><span class="line">地址 0x102: 34</span><br><span class="line">地址 0x103: 12</span><br></pre></td></tr></table></figure><p>判断当前主机的字节序通常可以通过一个简单的C程序实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;  </span><br><span class="line">    <span class="type">char</span> *p = (<span class="type">char</span> *)&amp;i;  </span><br><span class="line">    <span class="keyword">if</span>(*p == <span class="number">1</span>)  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Little-Endian\n&quot;</span>);  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Big-Endian\n&quot;</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>这个程序创建了一个整型数i，这个整型数在内存中占4个字节，然后取这个数的首字节，如果首字节是1，则为小端字节序；如果是0，则为大端字节序。</p><p>网络字节序通常使用大端，而主机字节序则取决于具体的机器。对于网络编程，我们需要使用相关的函数（如<code>htons</code>, <code>ntohs</code>, <code>htonl</code>, <code>ntohl</code>等）将主机字节序转换为网络字节序，或者将网络字节序转换为主机字节序。这样才能确保数据在不同的主机之间正确传输。</p><p>如果要使用联合体（union）来判断主机的字节序，你也可以使用下面的C语言代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">char</span> c[<span class="keyword">sizeof</span>(<span class="type">int</span>)];</span><br><span class="line">&#125; x;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    x.i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x.c[<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Little-Endian\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Big-Endian\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码创建了一个联合体，包含一个整数和一个字符数组。联合体的特点是所有成员共享同一块内存空间，因此，我们将整数1赋给<code>x.i</code>，然后查看字符数组<code>x.c[0]</code>的值。如果<code>x.c[0]</code>的值为1，则当前主机为小端序；否则，为大端序。</p><h3 id="三、线程"><a href="#三、线程" class="headerlink" title="三、线程"></a>三、线程</h3><p>怎么创建分离线程<br>怎么做到线程延迟运行<br>线程资源回收(主线程结束，分离线程资源是否回收？谁回收)</p><ol><li><p>创建分离线程</p><p>在C语言中，创建分离线程可以使用<code>pthread_attr_t</code>结构体，这是一个用于线程属性的结构体。以下是一个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">print_thread</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is a detached thread.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pthread_t</span> tid;</span><br><span class="line">    <span class="type">pthread_attr_t</span> attr;</span><br><span class="line"></span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line">    pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line">    pthread_create(&amp;tid, &amp;attr, print_thread, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    pthread_attr_destroy(&amp;attr);</span><br><span class="line">    <span class="comment">// Give the thread a chance to complete</span></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，我们首先初始化了一个线程属性对象attr，并使用<code>pthread_attr_setdetachstate()</code>将其设置为PTHREAD_CREATE_DETACHED，这样当我们用这个属性对象创建线程时，这个线程就是一个分离线程。</p></li><li><p>线程延迟运行</p><p>在C语言中，线程延迟运行可以通过<code>sleep()</code>函数实现。<code>sleep()</code>函数会使调用的线程挂起指定的秒数。如果你想延迟运行线程，你可以在线程的函数开始部分调用<code>sleep()</code>函数。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">print_thread</span><span class="params">(<span class="type">void</span> *arg)</span> &#123;</span><br><span class="line">    sleep(<span class="number">5</span>); <span class="comment">// delay for 5 seconds</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is a thread.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>线程资源回收</p><p>对于非分离状态的线程，主线程可以通过<code>pthread_join()</code>函数来等待子线程的结束，并回收其资源。但对于分离线程，当它们结束时，它们的资源会自动被系统回收。</p><p>对于主线程，如果主线程退出，它不会等待其他分离线程完成，除非你明确地调用<code>pthread_exit()</code>函数。如果主线程提前结束，可能会导致分离线程被迫提前结束，而不是正常完成。所以在设计程序时，要确保主线程在所有子线程完成之后再退出，或者使用<code>pthread_exit()</code>让主线程挂起，直到所有子线程完成。</p></li></ol><h3 id="四、进程"><a href="#四、进程" class="headerlink" title="四、进程"></a>四、进程</h3><p>fork子进程，子进程会继承主进程的fd吗<br>fork子进程后，主进程关闭fd，子进程是否会出问题<br>子进程关闭fd，主进程是否会出问题</p><ol><li><p><strong>fork子进程，子进程会继承主进程的fd吗？</strong></p><p>是的，当主进程（父进程）调用<code>fork()</code>创建子进程时，子进程会继承父进程的所有文件描述符（file descriptors）。这意味着父进程和子进程都有同样的文件描述符指向同一个文件表项。这个文件表项包含了文件的状态信息，如文件位置等。</p></li><li><p><strong>fork子进程后，主进程关闭fd，子进程是否会出问题？</strong></p><p>不会。当主进程关闭某个文件描述符后，这并不影响子进程对该文件描述符的使用。因为在子进程中，这个文件描述符是一个独立的副本，与主进程的文件描述符虽然指向同一个文件表项，但是是分开的。所以，主进程关闭文件描述符不会影响子进程。</p></li><li><p><strong>子进程关闭fd，主进程是否会出问题？</strong></p><p>同样，子进程关闭文件描述符也不会影响主进程。子进程的文件描述符和主进程的是独立的，一个进程关闭文件描述符并不会影响到另一个进程。</p></li></ol><p>这就是Unix风格的进程创建和文件描述符的工作方式。不过，对于文件描述符的管理，程序需要特别小心，因为不恰当的操作可能会引发意外的问题。例如，如果父子进程都在操作同一个文件描述符，而没有进行同步，可能会导致数据混乱。所以，在有这种需求的情况下，通常需要使用管道（pipe）、锁等机制进行同步。</p><h3 id="五、Coding"><a href="#五、Coding" class="headerlink" title="五、Coding"></a>五、Coding</h3><p>双向链表反置</p><p>实现双向链表反转，核心思想是将每个节点的前驱和后继指针互换，同时注意首尾节点的处理。假设我们有一个如下的双向链表结构（C语言）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">prev</span>;</span></span><br><span class="line">&#125; Node;</span><br></pre></td></tr></table></figure><p>下面是反转双向链表的C语言实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Node* <span class="title function_">reverseDoublyLinkedList</span><span class="params">(Node *head)</span> &#123;</span><br><span class="line">    Node *temp = <span class="literal">NULL</span>;</span><br><span class="line">    Node *current = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Swap next and prev for all nodes of doubly linked list</span></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        temp = current-&gt;prev;</span><br><span class="line">        current-&gt;prev = current-&gt;next;</span><br><span class="line">        current-&gt;next = temp;</span><br><span class="line">        current = current-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Before changing head, check for the cases like empty list and list with only one node</span></span><br><span class="line">    <span class="keyword">if</span>(temp != <span class="literal">NULL</span> )</span><br><span class="line">        head = temp-&gt;prev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的代码逐个遍历链表中的每一个节点，并将每个节点的前驱（prev）和后继（next）指针进行交换。遍历结束后，链表的首尾节点也完成了交换，从而实现了双向链表的反转。</p><p>需要注意的是，最后我们需要检查一下链表是否为空或只有一个节点的情况，因为在这些情况下，<code>temp-&gt;prev</code>可能是无效的，这就是我们在更改<code>head</code>之前需要进行检查的原因。</p><p>在C++中，我们可以使用相似的方法来反转双向链表。首先，我们假设你有以下的双向链表节点结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node *next;</span><br><span class="line">    Node *prev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面是如何使用C++来反转双向链表：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">reverseDoublyLinkedList</span><span class="params">(Node *head)</span> </span>&#123;</span><br><span class="line">    Node *current = head;</span><br><span class="line">    Node *temp = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        temp = current-&gt;prev;</span><br><span class="line">        current-&gt;prev = current-&gt;next;</span><br><span class="line">        current-&gt;next = temp;</span><br><span class="line">        current = current-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (temp != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        head = temp-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个C++的实现和C的实现基本上是一样的，都是在遍历链表的同时交换每个节点的前驱和后继指针。注意最后我们还要检查<code>temp</code>是否为空，来处理链表为空或只有一个节点的情况。</p><h3 id="六、epoll"><a href="#六、epoll" class="headerlink" title="六、epoll"></a>六、epoll</h3><p>epoll的两种模式，有何区别<br>边缘触发&#x2F;水平触发分别适合什么业务场景<br>边缘触发&#x2F;水平触发哪种对于操作系统性能更好</p><p><code>epoll</code>是Linux系统下的一种I&#x2F;O多路复用技术，其有两种工作模式：边缘触发（ET，Edge Triggered）和水平触发（LT，Level Triggered）。</p><ol><li><p>边缘触发（ET）：ET模式下，当监视的文件描述符从未就绪变为就绪状态时，epoll就会通过epoll_wait返回。如果后续还有数据到来，epoll不会再次通知你，直到该文件描述符再次从未就绪变为就绪状态，即出现新的变化边缘。</p></li><li><p>水平触发（LT）：LT模式下，只要监视的文件描述符还处在就绪状态，epoll就会通过epoll_wait返回。</p></li></ol><p>不同的模式适合处理不同的业务场景：</p><ul><li><p>边缘触发模式更适合于高性能服务器开发，它只在状态发生变化时返回，所以不会频繁地通知程序，这样可以减少程序的系统调用次数，节省CPU资源。但是，使用ET模式需要你一次性处理完所有的事件，如果处理不完，下次就不会再得到通知，因此适合于能够读&#x2F;写大量数据并且不会阻塞的场景。</p></li><li><p>水平触发模式则更适合于对<strong>实时性要求较高</strong>的程序，它会不断地通知程序有数据就绪。因此，对于一次无法处理完所有数据，或者处理数据可能会阻塞的场景，使用LT模式会更安全，因为你可以确保在下一次epoll_wait时仍然能得到通知。</p></li></ul><p>就操作系统性能来看，边缘触发模式一般来说对操作系统的性能更好，因为它减少了系统调用的次数。但是，选择哪种模式应根据你的具体需求和业务场景来定，因为不同的模式有不同的适用场景。</p><h3 id="七、http"><a href="#七、http" class="headerlink" title="七、http"></a>七、http</h3><p>是否使用过开源http服务器<br>http的头部首行是什么</p><ol><li><p><strong>是否使用过开源http服务器</strong></p><p>作为一个AI，我并未使用过任何软件，包括开源HTTP服务器。然而，我有大量的信息和知识关于各种开源HTTP服务器，比如Apache、Nginx、Lighttpd等。这些都是常用的开源HTTP服务器软件。</p></li><li><p><strong>HTTP的头部首行是什么</strong></p><p>HTTP的头部首行（首部行）会根据请求和响应有所不同。</p><ul><li><p>如果是HTTP请求，首行被称为请求行，格式是：<code>&lt;方法&gt; &lt;请求URI&gt; &lt;HTTP版本&gt;</code>。例如：<code>GET /index.html HTTP/1.1</code>，其中<code>GET</code>是请求的方法，<code>/index.html</code>是请求的资源URI，<code>HTTP/1.1</code>是HTTP协议的版本。</p></li><li><p>如果是HTTP响应，首行被称为状态行，格式是：<code>&lt;HTTP版本&gt; &lt;状态码&gt; &lt;状态文本&gt;</code>。例如：<code>HTTP/1.1 200 OK</code>，其中<code>HTTP/1.1</code>是HTTP协议的版本，<code>200</code>是HTTP的状态码，代表请求成功，<code>OK</code>是这个状态码对应的文本描述。</p></li></ul><p>Nginx（发音为 “engine X”）是一个高性能的HTTP和反向代理服务器，同时也是一个IMAP&#x2F;POP3&#x2F;SMTP代理服务器。Nginx由Igor Sysoev为rambler.ru网站（俄罗斯的一个很大的门户网站）开发，第一个公开版本0.1.0发布于2004年。Nginx在高连接并发的情况下，性能表现很好，因此被广泛地应用于高负载的Web服务场景。</p><p>以下是Nginx的一些主要特性：</p><ol><li><p><strong>反向代理与负载均衡</strong>：Nginx可以作为反向代理服务器，接受客户端的请求并将它们转发到适当的后端服务器，并将后端服务器的响应返回给客户端。它还提供了丰富的负载均衡策略，如轮询、最少连接、IP哈希等。</p></li><li><p><strong>静态内容处理</strong>：Nginx可以直接作为Web服务器使用，提供静态内容的服务。它在处理静态文件、索引文件以及自动索引时，表现出非常高的效率。</p></li><li><p><strong>缓存与压缩</strong>：Nginx可以缓存后端服务器的响应内容，并在下一次客户端请求时，直接返回缓存的内容，以减轻后端服务器的负载。它还支持响应内容的Gzip压缩，以减少网络传输的数据量。</p></li><li><p><strong>SSL与TLS支持</strong>：Nginx支持SSL和TLS协议，可以用来创建HTTPS服务器。</p></li><li><p><strong>模块化设计</strong>：Nginx的设计具有强大的模块化特性，有大量的第三方模块可供选择，也可以编写自定义模块。</p></li></ol><p>截至2021年，Nginx是全球使用最广泛的Web服务器之一，并被许多高流量的网站使用，包括Netflix、GitHub、MaxCDN等。</p></li></ol><h3 id="八、字符串翻转"><a href="#八、字符串翻转" class="headerlink" title="八、字符串翻转"></a>八、字符串翻转</h3><p>如果不使用标准库中的<code>std::reverse</code>函数，可以通过遍历字符串一半的长度，然后交换对应位置的字符来实现翻转。以下是一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(std::string&amp; str)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = str.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        std::<span class="built_in">swap</span>(str[i], str[n - i - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    <span class="built_in">reverseString</span>(str);</span><br><span class="line">    <span class="comment">// 现在，str是&quot;!dlroW ,olleH&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个<code>reverseString</code>函数遍历字符串的前一半，然后将每个字符与对应位置的字符交换。例如，第一个字符会与最后一个字符交换，第二个字符会与倒数第二个字符交换，依此类推。这样，就可以实现字符串的翻转。</p><p>这个函数和<code>std::reverse</code>一样，会就地翻转字符串。如果你不希望改变原来的字符串，你可以先复制这个字符串，然后再翻转。</p><h3 id="九、STL-中-vector-容器原理是什么-有什么缺点"><a href="#九、STL-中-vector-容器原理是什么-有什么缺点" class="headerlink" title="九、STL 中 vector 容器原理是什么?有什么缺点?"></a>九、STL 中 vector 容器原理是什么?有什么缺点?</h3><p>在C++的标准模板库（STL）中，<code>vector</code>是一种动态数组，它能够根据需要自动调整其大小，而且元素存储在连续的内存中。这个特性使得<code>vector</code>可以使用数组的随机访问操作，如索引操作符<code>[]</code>，同时也可以提供动态调整大小的功能。</p><p><code>vector</code>的工作原理基本上是通过<strong>内部指针</strong>指向一个动态分配的数组，同时保持追踪当前的<strong>大小</strong>（即<code>vector</code>中元素的数量）和<strong>容量</strong>（数组的实际大小）。当向<code>vector</code>添加元素，并且当前大小等于容量时，<code>vector</code>会重新分配一块更大的内存空间，将原有元素复制到新的内存空间，并释放旧的内存空间。</p><p><code>vector</code>的主要优点包括：提供动态大小的数组，能够随机访问元素，能够在末尾相对快速地添加或删除元素。</p><p>然而，<code>vector</code>也有一些缺点：</p><ol><li><p><strong>插入和删除非尾部元素的效率较低</strong>：因为<code>vector</code>是在内存中连续存储的，所以在<code>vector</code>的头部或者中间位置插入或删除元素时，需要移动其他的元素以保持连续，这会导致效率较低。</p></li><li><p><strong>内存使用可能不高效</strong>：当<code>vector</code>需要扩展容量时，它通常会分配比当前元素数量更多的内存空间，以备后续增长使用。这可以减少分配和复制操作的频率，但是在某些情况下，这可能会导致内存的浪费。</p></li><li><p><strong>可能发生内存重新分配</strong>：当<code>vector</code>增长并需要更多的内存空间时，它会分配新的内存块，并释放旧的内存块。这将导致<code>vector</code>的<strong>所有迭代器、指针和引用变得无效</strong>。如果代码依赖于这些迭代器、指针或引用，那么这就可能导致问题。</p></li></ol><p>总的来说，<code>vector</code>是一个非常强大和灵活的容器，可以满足许多常见的需求。然而，它并非在所有情况下都是最佳的选择，这时候可能需要考虑其他类型的容器，如<code>list</code>、<code>deque</code>等。</p><h3 id="1-求k个最大值"><a href="#1-求k个最大值" class="headerlink" title="1.求k个最大值"></a>1.求k个最大值</h3><p>stl中有优先队列，就是大根堆(默认大根堆)</p><h3 id="2-多态的优点"><a href="#2-多态的优点" class="headerlink" title="2.多态的优点"></a>2.多态的优点</h3><p>多态（Polymorphism）是面向对象编程中的一个重要概念，它具有许多优点，如下所述：</p><ol><li><p>灵活性和可扩展性：多态允许对象根据其实际类型来表现不同的行为。这意味着可以使用父类引用指向子类对象，并根据具体的子类类型调用相应的方法。这样，可以根据需要轻松地扩展和添加新的子类，而无需修改现有的代码。</p></li><li><p>可重用性：多态促进了代码的重用，因为可以通过一个通用的父类引用来处理多个不同的子类对象。这样可以减少代码的冗余，并使代码更加简洁和易于维护。</p></li><li><p>可替代性和统一接口：通过使用多态，可以在不改变客户端代码的情况下替换具体的子类对象。这使得系统更加灵活，并且可以轻松地切换实现，只需保持统一的接口即可。</p></li><li><p>可扩展性和可维护性：多态可以将代码的复杂性分散到多个相关的子类中。这样，每个子类只需关注自己的特定行为，使代码更加模块化、可扩展和可维护。</p></li><li><p>提高可读性：通过使用多态，可以编写更加抽象和通用的代码，从而提高代码的可读性和理解性。这使得其他开发人员更容易理解和使用代码，并且减少了出错的可能性。</p></li></ol><p>总的来说，多态使得代码更加灵活、可重用、可替代，同时提高了代码的可扩展性、可维护性和可读性。这些优点使得多态成为面向对象编程中一个非常有用的特性。</p><h3 id="1-atoi实现"><a href="#1-atoi实现" class="headerlink" title="1.atoi实现"></a>1.atoi实现</h3><p>在C++中，如果你想将字符串转换为整数，你可以使用标准库函数<code>std::stoi</code>（它会处理诸如空格、正负号和数字之外的字符，如果遇到不能转换的字符，会抛出<code>std::invalid_argument</code>异常）。但是，如果你想手动实现这个功能（相当于<code>atoi</code>），你可以写一个函数，遍历字符串中的每一个字符，逐步构建数字。这是一个可能的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">myAtoi</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> result = <span class="number">0</span>; <span class="comment">// Initialize result</span></span><br><span class="line">    <span class="type">int</span> sign = <span class="number">1</span>;  <span class="comment">// Initialize sign as positive</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">// Initialize index of first digit</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Skip any leading whitespace</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; str.<span class="built_in">size</span>() &amp;&amp; str[i] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        i++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if optional sign if it exists</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; str.<span class="built_in">size</span>() &amp;&amp; (str[i] == <span class="string">&#x27;+&#x27;</span> || str[i] == <span class="string">&#x27;-&#x27;</span>))</span><br><span class="line">        sign = (str[i++] == <span class="string">&#x27;-&#x27;</span>) ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Traverse through each digit of input string</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; str.<span class="built_in">size</span>() &amp;&amp; (str[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;9&#x27;</span>)) &#123;</span><br><span class="line">        <span class="comment">// Check if result will be out of bounds, if so, return INT_MAX or INT_MIN</span></span><br><span class="line">        <span class="keyword">if</span> (result &gt; INT_MAX / <span class="number">10</span> || (result == INT_MAX / <span class="number">10</span> &amp;&amp; str[i] - <span class="string">&#x27;0&#x27;</span> &gt; INT_MAX % <span class="number">10</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> (sign == <span class="number">1</span>) ? INT_MAX : INT_MIN;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Multiply result by 10 and add the current digit</span></span><br><span class="line">        result = result * <span class="number">10</span> + (str[i++] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result * sign;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数会检查输入字符串的符号（如果存在的话），然后遍历字符串的每个字符，只要它是数字，就将结果乘以10并加上当前数字。同时，如果在任何时候结果会超出<code>int</code>的范围，它将返回<code>INT_MAX</code>或<code>INT_MIN</code>。请注意，这个函数并不完全等同于<code>atoi</code>，因为<code>atoi</code>在遇到无法转换的字符时会返回到目前为止已经转换的结果，而不是抛出错误。</p><h3 id="2-编辑距离"><a href="#2-编辑距离" class="headerlink" title="2.编辑距离"></a>2.编辑距离</h3><p>编辑距离（Edit Distance），也称为Levenshtein距离，是衡量两个字符串之间相似度的度量标准。它定义为将一个字符串转换为另一个字符串所需的最小编辑操作次数，其中编辑操作可以是插入、删除或替换一个字符。</p><p>编辑距离可以用于比较两个字符串之间的相似性，例如拼写纠正、文字识别、自然语言处理等领域。它对于理解和处理文本数据非常有用。</p><p>编辑距离的计算方法基于动态规划算法。假设有两个字符串str1和str2，分别长度为m和n。可以使用一个m×n的矩阵来存储中间结果，其中矩阵的第i行第j列的值表示将str1的前i个字符转换为str2的前j个字符所需的最小编辑距离。</p><p>动态规划的过程中，可以通过以下三种编辑操作来更新矩阵中的值：</p><ol><li>插入（Insert）：将一个字符插入到一个字符串中。</li><li>删除（Delete）：从一个字符串中删除一个字符。</li><li>替换（Replace）：将一个字符替换为另一个字符。</li></ol><p>根据编辑操作的不同，可以将矩阵中的每个元素进行更新。最终，右下角的元素即为str1和str2之间的编辑距离。</p><p>编辑距离具有以下特性：</p><ol><li>非负性：编辑距离始终大于等于零。</li><li>对称性：编辑距离(str1, str2)等于编辑距离(str2, str1)。</li><li>三角不等式：对于三个字符串str1、str2和str3，编辑距离(str1, str3)不超过编辑距离(str1, str2)加上编辑距离(str2, str3)。</li></ol><p>编辑距离的计算可以用于多种场景，例如拼写纠正中建议正确的拼写，文本相似度匹配中找到相似的文本，以及DNA序列比对中寻找相似的基因序列等。</p><h4 id="以下是一个用C-编写的计算编辑距离的示例代码："><a href="#以下是一个用C-编写的计算编辑距离的示例代码：" class="headerlink" title="以下是一个用C++编写的计算编辑距离的示例代码："></a>以下是一个用C++编写的计算编辑距离的示例代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calculateEditDistance</span><span class="params">(<span class="type">const</span> std::string&amp; str1, <span class="type">const</span> std::string&amp; str2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m = str1.<span class="built_in">length</span>();</span><br><span class="line">    <span class="type">int</span> n = str2.<span class="built_in">length</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个二维矩阵用于存储编辑距离</span></span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化第一行和第一列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">        dp[<span class="number">0</span>][j] = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态规划计算编辑距离</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str1[i - <span class="number">1</span>] == str2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];  <span class="comment">// 字符相同，无需编辑操作</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="number">1</span> + std::<span class="built_in">min</span>(&#123;dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]&#125;);</span><br><span class="line">                <span class="comment">// 字符不同，选择插入、删除或替换操作中最小编辑距离的值，并加1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回右下角的元素，即为编辑距离</span></span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string str1 = <span class="string">&quot;kitten&quot;</span>;</span><br><span class="line">    std::string str2 = <span class="string">&quot;sitting&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> distance = <span class="built_in">calculateEditDistance</span>(str1, str2);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;编辑距离为：&quot;</span> &lt;&lt; distance &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码中，<code>calculateEditDistance</code>函数接受两个字符串作为输入，并返回它们之间的编辑距离。在<code>main</code>函数中，示例代码计算了字符串”kitten”和”sitting”之间的编辑距离，并输出结果。</p><p>请注意，这只是一个基本的示例代码，实际应用中可能需要根据具体情况进行优化和扩展。</p><h3 id="3-盛最多水的容器"><a href="#3-盛最多水的容器" class="headerlink" title="3.盛最多水的容器"></a>3.盛最多水的容器</h3><h4 id="木桶效应，更改短的那一边"><a href="#木桶效应，更改短的那一边" class="headerlink" title="木桶效应，更改短的那一边"></a>木桶效应，更改短的那一边</h4><p>题目：盛最多水的容器（Container With Most Water）</p><p>题目描述：给定n个非负整数a1，a2，…，an，其中每个点的坐标为(i, ai)。在坐标系内画n条垂直线，垂直线i的两个端点分别为(i, ai)和(i, 0)。找出两条线，使得它们与x轴共同构成的容器可以容纳最多的水。</p><p>解题思路：这道题可以使用双指针的方法来解决。我们可以使用两个指针，一个指向数组的起始位置，一个指向数组的末尾位置。然后计算当前指针所围成的区域的面积，并记录最大面积。接下来，根据双指针的移动规则，移动指针并更新最大面积，直到两个指针相遇。</p><p>移动指针的规则如下：</p><ul><li>如果左指针指向的高度小于右指针指向的高度，则左指针向右移动一格。</li><li>如果左指针指向的高度大于等于右指针指向的高度，则右指针向左移动一格。</li></ul><p>这个规则的原理是，我们想要容器的面积最大化，而容器的面积受到较短边的限制。移动较长边不会使面积增大，因为容器的高度由较短边决定，而底边的长度在减小。因此，我们移动较短边，以期望找到更高的边。</p><p>C++代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> right = height.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> area = (right - left) * std::<span class="built_in">min</span>(height[left], height[right]);</span><br><span class="line">        maxArea = std::<span class="built_in">max</span>(maxArea, area);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (height[left] &lt; height[right]) &#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxArea;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个代码中，我们使用<code>left</code>和<code>right</code>分别表示左指针和右指针的位置，<code>maxArea</code>用于记录最大面积。在<code>while</code>循环中，计算当前指针所围成的区域的面积，并更新最大面积。然后根据双指针的移动规则移动指针，直到两个指针相遇。最后返回最大面积。</p><p>这段代码的时间复杂度为O(n)，其中n为数组的长度。通过使用双指针的方法，我们可以在一次遍历中找到最大面积，从而提高算法的效率。</p><h3 id="4-给你一个二叉搜索树，找值为n的出现的次数"><a href="#4-给你一个二叉搜索树，找值为n的出现的次数" class="headerlink" title="4.给你一个二叉搜索树，找值为n的出现的次数"></a>4.给你一个二叉搜索树，找值为n的出现的次数</h3><p>要在二叉搜索树中找到值为n的出现次数，可以采用以下步骤：</p><ol><li><p>遍历二叉搜索树，可以使用中序遍历的方式（左子树 -&gt; 根节点 -&gt; 右子树）。中序遍历可以保证二叉搜索树中的节点按照值的升序排列。</p></li><li><p>在遍历的过程中，比较每个节点的值与目标值n的大小关系。如果当前节点的值等于n，则将计数器加1。</p></li></ol><p>下面是一个示例的C++代码，用于在二叉搜索树中计算值为n的出现次数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode* left;</span><br><span class="line">    TreeNode* right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inorderTraversal</span><span class="params">(TreeNode* root, <span class="type">int</span> n, <span class="type">int</span>&amp; count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">inorderTraversal</span>(root-&gt;left, n, count);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val == n) &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">inorderTraversal</span>(root-&gt;right, n, count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findValueCount</span><span class="params">(TreeNode* root, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">inorderTraversal</span>(root, n, count);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 构建一个二叉搜索树</span></span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">5</span>);</span><br><span class="line">    root-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">3</span>);</span><br><span class="line">    root-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">7</span>);</span><br><span class="line">    root-&gt;left-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">2</span>);</span><br><span class="line">    root-&gt;left-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">4</span>);</span><br><span class="line">    root-&gt;right-&gt;left = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">6</span>);</span><br><span class="line">    root-&gt;right-&gt;right = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> target = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="built_in">findValueCount</span>(root, target);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;值为&quot;</span> &lt;&lt; target &lt;&lt; <span class="string">&quot;的出现次数为：&quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，我们定义了一个二叉搜索树的结构<code>TreeNode</code>，并实现了<code>inorderTraversal</code>函数来进行中序遍历，同时统计值为n的出现次数。最后，在<code>findValueCount</code>函数中调用<code>inorderTraversal</code>函数，并返回最终的出现次数。</p><p>请注意，这只是一个简单的示例代码，实际应用中可能需要根据具体情况进行优化和扩展。</p><h3 id="5-Linux命令去除一个文件中的重复宏定义"><a href="#5-Linux命令去除一个文件中的重复宏定义" class="headerlink" title="5.Linux命令去除一个文件中的重复宏定义"></a>5.Linux命令去除一个文件中的重复宏定义</h3><p>要用Linux命令去除文件中的重复宏定义，可以使用以下步骤：</p><ol><li><p>使用<code>sort</code>命令对文件进行排序，并使用<code>-u</code>选项去除重复行。假设要处理的文件名为<code>input.txt</code>，可以执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort -u input.txt &gt; output.txt</span><br></pre></td></tr></table></figure><p>该命令将会将排序后的结果写入<code>output.txt</code>文件中，并且已去除了重复的行。</p></li><li><p>如果文件中存在空行或者注释行，可以使用<code>grep</code>命令结合正则表达式来过滤掉这些行。假设需要过滤掉以<code>#</code>开头的注释行和空行，可以执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -vE &quot;^\s*(#|$)&quot; input.txt | sort -u &gt; output.txt</span><br></pre></td></tr></table></figure><p>该命令使用<code>-v</code>选项来反转匹配结果，即过滤掉匹配的行；<code>-E</code>选项用于启用扩展的正则表达式；正则表达式<code>&quot;^\s*(#|$)&quot;</code>匹配以<code>#</code>开头的注释行和空行。</p></li></ol><p>注意：上述命令处理的是每一行作为一个整体的重复行。如果需要去除文件中的连续重复行（即多个连续相同的宏定义只保留一个），可以使用<code>uniq</code>命令。假设要处理的文件名为<code>input.txt</code>，可以执行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uniq input.txt &gt; output.txt</span><br></pre></td></tr></table></figure><p>这将会将去除连续重复行后的结果写入<code>output.txt</code>文件中。</p><p>使用这些命令可以方便地去除文件中的重复宏定义，根据实际需要选择合适的方法。</p><h3 id="6-fork子进程的过程会复制哪些信息，有哪些信息是子进程不能动的"><a href="#6-fork子进程的过程会复制哪些信息，有哪些信息是子进程不能动的" class="headerlink" title="6.fork子进程的过程会复制哪些信息，有哪些信息是子进程不能动的"></a>6.fork子进程的过程会复制哪些信息，有哪些信息是子进程不能动的</h3><p>当调用fork()函数创建子进程时，操作系统会复制父进程的一些信息给子进程。以下是在fork()时复制的信息：</p><ol><li><p>进程上下文：子进程会获得父进程的进程ID（PID）和父进程的用户ID（UID）等信息。</p></li><li><p>内存映像：子进程会复制父进程的虚拟地址空间，包括代码段、数据段和堆栈段。但是，这是使用写时复制（Copy-On-Write）技术实现的，即只有在需要修改内存内容时才会进行实际的复制。</p></li><li><p>文件描述符表：子进程会复制父进程的文件描述符表，包括打开的文件描述符和相应的文件偏移量。</p></li><li><p>进程资源：子进程会继承父进程的打开的文件、网络连接、信号处理器、定时器、环境变量等资源。</p></li></ol><p>在子进程复制父进程的信息时，有一些信息是子进程不能改变的，这些信息包括：</p><ol><li><p>进程ID（PID）：子进程会获得父进程的PID，它是在创建子进程时分配的唯一标识符，不能被子进程修改。</p></li><li><p>父进程ID（PPID）：子进程会获得父进程的PPID，它指示了子进程的父进程是哪个进程，也是不可修改的。</p></li><li><p>用户ID（UID）和组ID（GID）：子进程会继承父进程的UID和GID，用于标识进程的所有者。子进程无法修改这些信息。</p></li><li><p>文件描述符的打开状态：子进程会继承父进程的文件描述符，但是子进程无法关闭父进程已打开的文件描述符。</p></li></ol><p>总之，当调用fork()函数创建子进程时，子进程会复制父进程的进程上下文、内存映像、文件描述符表和进程资源等信息。子进程无法改变父进程的进程ID、父进程ID、用户ID、组ID和文件描述符的打开状态。</p><h3 id="7-智能指针和自动语义"><a href="#7-智能指针和自动语义" class="headerlink" title="7.智能指针和自动语义"></a>7.智能指针和自动语义</h3><h4 id="C-中的智能指针"><a href="#C-中的智能指针" class="headerlink" title="C++中的智能指针"></a>C++中的智能指针</h4><p>是一种用于管理动态分配内存的工具，它们可以帮助开发者更方便地管理内存，避免内存泄漏和悬挂指针等问题。C++标准库提供了三种常见的智能指针：unique_ptr、shared_ptr和weak_ptr。</p><ol><li><p>unique_ptr：unique_ptr允许独占地拥有所管理的对象。它确保只有一个unique_ptr可以指向一个对象，并在其生命周期结束时自动释放内存。当unique_ptr被销毁或重置时，它所管理的对象也会被销毁。unique_ptr提供了类似指针的操作，可以通过<code>get</code>函数获取原始指针，以及通过<code>release</code>函数释放所有权。</p></li><li><p>shared_ptr：shared_ptr允许多个shared_ptr共享对同一对象的访问。它通过引用计数来管理内存的释放，即每个shared_ptr维护一个计数器，记录有多少个shared_ptr指向同一个对象。只有当最后一个shared_ptr析构或被重置时，才会释放所管理的对象。shared_ptr通过使用<code>make_shared</code>函数或<code>std::make_shared</code>函数进行创建，并可以使用<code>get</code>函数获取原始指针。</p></li><li><p>weak_ptr：weak_ptr是shared_ptr的一种扩展，它解决了shared_ptr可能导致的循环引用问题。weak_ptr可以引用一个由shared_ptr管理的对象，但不会增加引用计数。weak_ptr的存在不会阻止所管理对象的销毁。可以通过<code>lock</code>函数将weak_ptr转换为shared_ptr，如果所管理的对象仍然存在，则返回有效的shared_ptr，否则返回空的shared_ptr。</p></li></ol><h4 id="C-中的自动语义"><a href="#C-中的自动语义" class="headerlink" title="C++中的自动语义"></a>C++中的自动语义</h4><p>是一种语言特性，通过编译器自动推导变量的类型。自动语义可以简化代码编写过程，减少显式类型声明的需要，并提高代码的可读性和可维护性。C++中的自动语义由<code>auto</code>关键字和类型推导规则支持。</p><p>使用<code>auto</code>关键字可以让编译器根据变量的初始化表达式自动推导出其类型。编译器会根据等号右侧的表达式来确定变量的类型，并在编译时进行类型检查。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">10</span>;  <span class="comment">// x被推导为int类型</span></span><br><span class="line"><span class="keyword">auto</span> name = <span class="string">&quot;John&quot;</span>;  <span class="comment">// name被推导为const char*类型</span></span><br><span class="line"><span class="keyword">auto</span> result = <span class="built_in">add</span>(a, b);  <span class="comment">// result被推导为函数add的返回类型</span></span><br></pre></td></tr></table></figure><p>自动语义在C++11标准中引入，它可以与模板、范围基于循环、lambda表达式等特性结合使用，提供更简洁和灵活的代码编写方式。然而，需要注意的是，自动语义并不意味着完全放弃显式类型声明，而是允许开发者根据需要选择使用自动类型推导或显式类型声明。这样可以在代码编写过程中根据上下文的需要选择合适的方式。</p><h3 id="8-linux一个程序在运行的时候，这个程序的文件能被删除吗"><a href="#8-linux一个程序在运行的时候，这个程序的文件能被删除吗" class="headerlink" title="8.linux一个程序在运行的时候，这个程序的文件能被删除吗"></a>8.linux一个程序在运行的时候，这个程序的文件能被删除吗</h3><p>在Linux系统中，一个程序在运行时其对应的可执行文件是被加载到内存中执行的，而与其关联的文件本身是不会被修改或删除的。因此，当一个程序在运行时，其对应的可执行文件仍然存在磁盘上，而且仍然可以被其他进程或用户读取或修改。</p><p>当一个文件被打开并被某个程序使用时，即使将该文件删除，该程序仍然可以继续访问该文件，因为打开文件时已经通过文件描述符建立了文件和程序之间的连接。因此，程序可以继续读取、写入或操作该文件，直到关闭文件描述符。</p><p>当文件被删除后，其目录项被删除，但文件内容在文件描述符关闭之前仍然存在于磁盘上。只有当没有任何进程打开该文件（即没有文件描述符引用该文件）时，文件系统才会将文件空间释放，并将其标记为可重用的。</p><p>需要注意的是，虽然程序可以继续访问已打开的文件，但其他用户或进程无法通过文件名直接访问该文件。只有当所有引用该文件的文件描述符关闭后，该文件才会完全从文件系统中删除。</p><p>总结起来，在Linux系统中，一个程序在运行时，其对应的文件可以被删除，但是该文件仍然可以被程序访问，直到关闭对应的文件描述符。其他用户或进程无法直接访问已删除的文件，除非它们已经打开了该文件并持有文件描述符。</p><h3 id="9-引用和指针的区别"><a href="#9-引用和指针的区别" class="headerlink" title="9.引用和指针的区别"></a>9.引用和指针的区别</h3><ul><li>引用是别名，必须在<strong>声明时初始化</strong>，并且一旦初始化后，就不能改变指向。引用本身并<strong>不占用内存</strong>，它只是对已存在变量的一个别名，但是在函数参数中使用引用时，编译器可能会为其分配内存。</li><li>指针是一个<strong>实体</strong>，是指向内存空间的<strong>变量</strong>。它本身有<strong>独立</strong>的存储空间，并且可以<strong>更改</strong>指向。</li></ul><h3 id="10，C-中多态"><a href="#10，C-中多态" class="headerlink" title="10，C++中多态"></a>10，C++中多态</h3><p>是的，多态在C++中主要有两种形式：静态多态（编译时多态）和动态多态（运行时多态）。</p><ol><li><p>静态多态：这是通过模板和函数重载实现的。编译器在编译阶段就会选择合适的函数或模板，因此它被称为编译时多态。因为函数调用是在编译阶段就确定了，所以静态多态的效率比动态多态高。</p></li><li><p>动态多态：这是通过虚函数实现的。在运行时，根据对象的实际类型来决定调用哪个函数，这就是所谓的运行时多态。实现动态多态需要额外的时间和空间开销，因为需要维护虚函数表和虚函数指针。</p></li></ol><p>在我前面的回答中，我讲述的是动态多态的实现方式。但确实，C++中的多态包括这两种形式。感谢你提醒我补充这个内容。</p><ul><li>通过基类定义虚函数。</li><li>创建派生类，并重写该虚函数。</li><li>使用基类指针（或引用）指向派生类对象，调用虚函数，从而实现多态。</li></ul><h3 id="11-虚函数实现的具体机制"><a href="#11-虚函数实现的具体机制" class="headerlink" title="11.虚函数实现的具体机制"></a>11.虚函数实现的具体机制</h3><p>在C++中，每个有虚函数的类都有一个虚函数表（vtable），这是一个存储类成员函数地址的数组。每个类的对象都有一个指向这个虚函数表的指针（vptr）。当我们通过基类的指针或引用调用虚函数时，实际上是根据vptr找到vtable，然后调用相应的函数。</p><h3 id="12-vector清除数据"><a href="#12-vector清除数据" class="headerlink" title="12.vector清除数据"></a>12.vector清除数据</h3><p>的方法是调用其成员函数<strong>clear()<strong>。调用clear()会删除vector中所有的元素，但</strong>不会释放</strong>vector所占用的内存。如果想要释放vector所占用的内存，可以使用<strong>swap函数</strong>或是手动创建一个新的临时vector，然后使用swap交换内存。</p><h3 id="13-内联函数"><a href="#13-内联函数" class="headerlink" title="13.内联函数"></a>13.内联函数</h3><p>是为了减少函数调用开销的一种优化方式。</p><p>显示内联是在函数声明或定义时使用<strong>inline关键字</strong>，隐式内联是在类定义中<strong>定义的成员函数</strong>，默认情况下它们都是内联的。</p><p>但实际上，编译器是否真正地将这些函数内联，还取决于编译器的优化决策，如果函数体太复杂，可能即使声明为内联，编译器也不会进行内联。</p><h3 id="14-C-的智能指针"><a href="#14-C-的智能指针" class="headerlink" title="14.C++的智能指针"></a>14.C++的智能指针</h3><p>是一类对象，它们表现得像指针，但可以自动管理所指向的内存。主要有三种类型的智能指针：</p><ul><li>unique_ptr: 一种独占所有权的智能指针，同一时间只能有一个unique_ptr指向给定的对象。</li><li>shared_ptr: 允许多个指针引用同一个对象，内部实现了引用计数，当最后一个shared_ptr离开作用域或被删除时，它所指向的内存会被释放。</li><li>weak_ptr: 一种不改变引用计数的智能指针，常用于解决shared_ptr可能导致的</li></ul><p>循环引用问题。</p><h3 id="15-左值引用和右值引用"><a href="#15-左值引用和右值引用" class="headerlink" title="15.左值引用和右值引用"></a>15.左值引用和右值引用</h3><p>C++11开始引入了左值引用和右值引用的概念。左值引用就是我们通常说的引用，必须绑定到一个左值上；右值引用则可以绑定到一个右值（例如临时对象）上。右值引用的主要应用场景是实现移动语义和完美转发，从而提高代码的效率。</p><h4 id="左值和右值是C-中的两种表达式分类。"><a href="#左值和右值是C-中的两种表达式分类。" class="headerlink" title="左值和右值是C++中的两种表达式分类。"></a>左值和右值是C++中的两种表达式分类。</h4><p>左值是可以在等号左边出现的表达式，它们有确定的内存地址，例如变量。右值是只能出现在等号右边的表达式，它们通常是临时的，无法寻址，例如字面量和临时对象。</p><h4 id="移动语义和完美转发："><a href="#移动语义和完美转发：" class="headerlink" title="移动语义和完美转发："></a>移动语义和完美转发：</h4><ul><li><p>移动语义：C++11引入了一种称为“移动语义”的新特性，它允许编译器避免不必要的拷贝，从而提高效率。在移动语义中，一个对象的资源（例如动态内存）可以被”移动”到另一个对象，原来的对象失去了对这些资源的所有权，并被置于一个有效但未定义的状态。移动语义主要通过右值引用和特殊的成员函数（移动构造函数和移动赋值运算符）实现。</p></li><li><p>完美转发：这是一种技术，可以在函数模板中保持参数的类型和值类别（左值或右值）。它主要通过类型推导和引用折叠实现。完美转发的主要目的是实现高效的代码重用。例如，你可以编写一个函数模板，它接受任意数量和类型的参数，并将它们完美转发给另一个函数。这在实现如std::make_shared、std::make_unique等函数时非常有用。</p></li></ul><p>好的，下面我将举例说明一下移动语义和完美转发：</p><ol><li>移动语义：</li></ol><p>假设我们有一个类，它管理一段动态分配的内存：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BigData</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BigData</span>(<span class="type">size_t</span> size) : <span class="built_in">size_</span>(size), <span class="built_in">data_</span>(<span class="keyword">new</span> <span class="type">int</span>[size]) &#123; &#125;</span><br><span class="line">    ~<span class="built_in">BigData</span>() &#123; <span class="keyword">delete</span>[] data_; &#125;</span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="built_in">BigData</span>(<span class="type">const</span> BigData&amp; other) : <span class="built_in">size_</span>(other.size_), <span class="built_in">data_</span>(<span class="keyword">new</span> <span class="type">int</span>[other.size_]) &#123;</span><br><span class="line">        std::<span class="built_in">copy</span>(other.data_, other.data_ + size_, data_);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他成员...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">size_t</span> size_;</span><br><span class="line">    <span class="type">int</span>* data_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，如果我们尝试拷贝一个BigData对象，就需要分配一块新的内存并复制所有数据。这可能很耗时。通过使用移动语义，我们可以避免这种额外的开销：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BigData</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ... 其他成员...</span></span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">BigData</span>(BigData&amp;&amp; other) <span class="keyword">noexcept</span> : <span class="built_in">size_</span>(other.size_), <span class="built_in">data_</span>(other.data_) &#123;</span><br><span class="line">        other.size_ = <span class="number">0</span>;</span><br><span class="line">        other.data_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 移动赋值运算符</span></span><br><span class="line">    BigData&amp; <span class="keyword">operator</span>=(BigData&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] data_;</span><br><span class="line">            size_ = other.size_;</span><br><span class="line">            data_ = other.data_;</span><br><span class="line">            other.size_ = <span class="number">0</span>;</span><br><span class="line">            other.data_ = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这是一个移动构造函数的实现，它使得一个新的 <code>BigData</code> 对象可以从另一个即将销毁或不再需要的 <code>BigData</code> 对象中 “移动”（而不是复制）资源。这通常发生在临时对象（即右值）上，因此参数类型是 <code>BigData&amp;&amp;</code>，表示右值引用。</p><p>让我们分步解析这段代码：</p><ul><li><p><code>BigData(BigData&amp;&amp; other) noexcept</code> 是移动构造函数的声明。其中 <code>BigData&amp;&amp; other</code> 表示右值引用类型的参数，<code>noexcept</code> 指示这个函数不会抛出任何异常。</p></li><li><p><code>: size_(other.size_), data_(other.data_)</code> 是成员初始化列表。它使得新对象的 <code>size_</code> 和 <code>data_</code> 成员直接接管 <code>other</code> 的资源，也就是说，它们现在指向了 <code>other</code> 之前管理的内存。</p></li><li><p><code>other.size_ = 0; other.data_ = nullptr;</code> 这两行代码使 <code>other</code> 处于一个安全但未定义的状态。它的大小被设为 0，数据指针被设为 <code>nullptr</code>。这是因为，新对象现在已经接管了 <code>other</code> 之前的资源，所以必须保证 <code>other</code> 在被销毁时不会再去释放这些资源。</p></li></ul><p>总的来说，这个移动构造函数的作用是，把 <code>other</code> 的资源转移到新对象，并将 <code>other</code> 置于一个状态，使其在被销毁时不会影响新对象所接管的资源。这个过程中没有发生任何资源的复制，因此比传统的拷贝构造函数更高效。</p><p>在移动构造函数和移动赋值运算符中，我们只是将资源（指针和大小）从一个对象移动到另一个对象，并将原对象置于一个安全的状态（大小为0，指针为nullptr）。这避免了不必要的内存分配和数据复制。</p><h4 id="完美转发："><a href="#完美转发：" class="headerlink" title="完美转发："></a>完美转发：</h4><p>假设我们有一个函数，它接受两个参数，并且我们有一个模板函数，我们希望它可以将参数完美转发给那个函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>&amp; x, <span class="type">int</span>&amp; y)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do something with x and y...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T1&amp;&amp; t1, T2&amp;&amp; t2)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(std::forward&lt;T1&gt;(t1), std::forward&lt;T2&gt;(t2));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">wrapper</span>(a, b);  <span class="comment">// 传递给func的是左值</span></span><br><span class="line">    <span class="built_in">wrapper</span>(<span class="number">3</span>, <span class="number">4</span>);  <span class="comment">// 传递给func的是右值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，wrapper函数模板通过类型推导和std::forward函数实现了完美转发。这使得它可以将它的参数（无论是左值还是右值）完美地转发给func函数。</p><h3 id="16-无锁编程"><a href="#16-无锁编程" class="headerlink" title="16.无锁编程"></a>16.无锁编程</h3><p>无锁编程（Lock-Free Programming）是一种使用原子操作（Atomic Operations）代替互斥量或者其他锁机制来同步并发线程的技术。无锁编程的目标是提高线程的并行性，并避免像死锁或者饥饿这样的常见问题。</p><p>以下是几种常见的无锁数据结构和算法：</p><ol><li><p><strong>无锁队列（Lock-Free Queue）</strong>：这是一种并发数据结构，它允许多个线程在没有锁的情况下进行入队和出队操作。无锁队列通常使用原子操作，例如比较并交换（Compare-and-Swap，简称CAS）来保证线程间的同步。</p></li><li><p><strong>无锁栈（Lock-Free Stack）</strong>：这也是一种并发数据结构，它允许多个线程在没有锁的情况下进行压栈和弹栈操作。无锁栈同样使用原子操作，如CAS来保证线程间的同步。</p></li><li><p><strong>无锁哈希表（Lock-Free Hash Table）</strong>：这是一种能够支持无锁插入、删除和查找操作的哈希表。实现无锁哈希表的难度较高，但可以通过细粒度的同步和复杂的算法来实现。</p></li><li><p><strong>无锁环形缓冲区（Lock-Free Circular Buffer）</strong>：这是一种常用于<strong>生产者消费者</strong>问题的数据结构。如果只有一个生产者线程和一个消费者线程，那么可以无需锁就能够安全地进行数据的读写操作。</p></li></ol><p>无锁编程往往更复杂，也更容易出错，但是如果正确实现，通常可以提供优于锁定机制的性能。此外，还有一种被称为“无等待（Wait-Free）”的编程模型，它进一步提供了每个线程都能在有限步内完成操作的保证，而无锁编程则只能保证系统级的进展（即总有线程能够完成操作，但具体是哪个线程则不确定）。</p><h3 id="17-子线程怎么创建出来的"><a href="#17-子线程怎么创建出来的" class="headerlink" title="17.子线程怎么创建出来的"></a>17.子线程怎么创建出来的</h3><p>在C++中，子线程（也称为工作线程）的创建通常使用<code>std::thread</code>库。你可以将一个函数（可以是普通函数，可以是类的成员函数，也可以是Lambda表达式）作为<code>std::thread</code>构造函数的参数，这个函数将在新创建的线程中执行。下面是一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">worker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello, World from worker thread!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::thread <span class="title">t</span><span class="params">(worker)</span></span>;  <span class="comment">// 创建并启动子线程</span></span><br><span class="line">    t.<span class="built_in">join</span>();  <span class="comment">// 等待子线程结束</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，子线程执行了<code>worker</code>函数。注意，在开始新的线程后，通常需要调用<code>std::thread::join</code>方法等待子线程完成。否则，如果主线程比子线程先结束，子线程可能会被突然终止。</p><h3 id="18-子线程能访问整个进程地址空间吗"><a href="#18-子线程能访问整个进程地址空间吗" class="headerlink" title="18.子线程能访问整个进程地址空间吗"></a>18.子线程能访问整个进程地址空间吗</h3><p>对于你的第二个问题，子线程可以访问进程的整个地址空间。在同一个进程中，所有的线程共享相同的地址空间，所以它们可以访问相同的全局变量，静态变量和堆上的内存。但请注意，每个线程都有自己的栈，所以一个线程无法直接访问另一个线程的栈变量。</p><p>尽管线程间的数据共享带来了一些便利，但同时也增加了并发问题的复杂性。当多个线程同时访问和修改相同的内存位置时，就需要进行适当的同步以防止数据竞态和其他并发问题。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/10/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E9%98%85%E8%AF%BB%E5%B0%8F%E8%AE%B0/"/>
      <url>/2023/10/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E9%98%85%E8%AF%BB%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<ol><li><h1 id="汇编语言为不同高级语言的不同编译器提供了通用的输出语句"><a href="#汇编语言为不同高级语言的不同编译器提供了通用的输出语句" class="headerlink" title="汇编语言为不同高级语言的不同编译器提供了通用的输出语句"></a>汇编语言为不同高级语言的不同编译器提供了通用的输出语句</h1></li></ol><p>(但是更深层地去看的话，汇编语言的种类也和指令集有关系)</p><ol><li><h1 id="i-预处理-s-编译后的汇编语言表示-文件都是文本文件"><a href="#i-预处理-s-编译后的汇编语言表示-文件都是文本文件" class="headerlink" title="i(预处理),.s(编译后的汇编语言表示)文件都是文本文件"></a>i(预处理),.s(编译后的汇编语言表示)文件都是文本文件</h1></li><li><h1 id="内存是一个临时存储设备，这个临时指的是处理器执行程序时"><a href="#内存是一个临时存储设备，这个临时指的是处理器执行程序时" class="headerlink" title="内存是一个临时存储设备，这个临时指的是处理器执行程序时"></a>内存是一个临时存储设备，这个临时指的是处理器执行程序时</h1></li><li><h1 id="控制器和适配器的区别"><a href="#控制器和适配器的区别" class="headerlink" title="控制器和适配器的区别"></a>控制器和适配器的区别</h1></li></ol><p>封装方式不同:</p><p>控制器:IO设备本身或者系统主板上的芯片组</p><p>适配器:插在主板插槽上的卡</p><h2 id="相同点：都是在IO总线和IO设备间传递信息"><a href="#相同点：都是在IO总线和IO设备间传递信息" class="headerlink" title="相同点：都是在IO总线和IO设备间传递信息"></a>相同点：都是在IO总线和IO设备间传递信息</h2><ol><li><h1 id="高速缓存至关重要-系统花费大量时间把信息从一个地方挪到另一个地方"><a href="#高速缓存至关重要-系统花费大量时间把信息从一个地方挪到另一个地方" class="headerlink" title="高速缓存至关重要:系统花费大量时间把信息从一个地方挪到另一个地方"></a>高速缓存至关重要:系统花费大量时间把信息从一个地方挪到另一个地方</h1></li><li><h2 id="利用局部性原理，在处理器-寄存器-和主存之间加入一系列的cache-造价始终速度接近寄存器"><a href="#利用局部性原理，在处理器-寄存器-和主存之间加入一系列的cache-造价始终速度接近寄存器" class="headerlink" title="利用局部性原理，在处理器(寄存器)和主存之间加入一系列的cache(造价始终速度接近寄存器)"></a>利用局部性原理，在处理器(寄存器)和主存之间加入一系列的cache(造价始终速度接近寄存器)</h2></li><li><h1 id="存储设备等级，在某些具有分布式文件系统的网络系统中，本地磁盘就是存储在其他系统中磁盘的高速缓存"><a href="#存储设备等级，在某些具有分布式文件系统的网络系统中，本地磁盘就是存储在其他系统中磁盘的高速缓存" class="headerlink" title="存储设备等级，在某些具有分布式文件系统的网络系统中，本地磁盘就是存储在其他系统中磁盘的高速缓存"></a>存储设备等级，在某些具有分布式文件系统的网络系统中，本地磁盘就是存储在其他系统中磁盘的高速缓存</h1></li><li><h1 id="操作系统的两个基本功能"><a href="#操作系统的两个基本功能" class="headerlink" title="操作系统的两个基本功能"></a>操作系统的两个基本功能</h1></li><li><h2 id="防止硬件被失控的应用程序滥用"><a href="#防止硬件被失控的应用程序滥用" class="headerlink" title="防止硬件被失控的应用程序滥用"></a>防止硬件被失控的应用程序滥用</h2></li></ol><p>e.g. 安卓系统的应用老是试图读定位，if没有os，会比现在更猖狂</p><ol><li><h2 id="向应用程序提供简单一致的机制来控制复杂而通常又大不相同的低级硬件设备"><a href="#向应用程序提供简单一致的机制来控制复杂而通常又大不相同的低级硬件设备" class="headerlink" title="向应用程序提供简单一致的机制来控制复杂而通常又大不相同的低级硬件设备"></a>向应用程序提供简单一致的机制来控制复杂而通常又大不相同的低级硬件设备</h2></li><li><h2 id="如何实现-通过几个基本的抽象概念来实现这两个功能"><a href="#如何实现-通过几个基本的抽象概念来实现这两个功能" class="headerlink" title="如何实现:通过几个基本的抽象概念来实现这两个功能"></a>如何实现:通过几个基本的抽象概念来实现这两个功能</h2></li><li><h3 id="文件：是对IO设备的抽象表示"><a href="#文件：是对IO设备的抽象表示" class="headerlink" title="文件：是对IO设备的抽象表示"></a>文件：是对IO设备的抽象表示</h3></li><li><h3 id="虚拟内存-是对主存和磁盘IO设备的抽象表示"><a href="#虚拟内存-是对主存和磁盘IO设备的抽象表示" class="headerlink" title="虚拟内存:是对主存和磁盘IO设备的抽象表示"></a>虚拟内存:是对主存和磁盘IO设备的抽象表示</h3></li><li><h3 id="进程-是对处理器、主存和IO设备的抽象表示"><a href="#进程-是对处理器、主存和IO设备的抽象表示" class="headerlink" title="进程:是对处理器、主存和IO设备的抽象表示"></a>进程:是对处理器、主存和IO设备的抽象表示</h3></li><li><h4 id="os对一个正在运行的程序的一种抽象"><a href="#os对一个正在运行的程序的一种抽象" class="headerlink" title="os对一个正在运行的程序的一种抽象"></a>os对一个正在运行的程序的一种抽象</h4><p> hello这样的程序在现代os上运行时，os会提供一种假象，就好像系统上只有这个程序在运行。程序看上去是独占地使用处理器、主存和IO设备。处理器看上去就是在不间断地一条一条地执行程序中的指令，也就是说看起来该程序的代码和数据是系统内存中的唯一对象。这个假象是通过进程(os对一个正在运行的程序的抽象)这一概念实现的。</p></li><li><h1 id="逻辑运算和位运算的不同"><a href="#逻辑运算和位运算的不同" class="headerlink" title="逻辑运算和位运算的不同"></a>逻辑运算和位运算的不同</h1></li><li><h2 id="逻辑运算认为所有非零的参数都表示成TRUE，但是位运算只有在为1时才为真"><a href="#逻辑运算认为所有非零的参数都表示成TRUE，但是位运算只有在为1时才为真" class="headerlink" title="逻辑运算认为所有非零的参数都表示成TRUE，但是位运算只有在为1时才为真"></a>逻辑运算认为所有非零的参数都表示成TRUE，但是位运算只有在为1时才为真</h2></li><li><h2 id="逻辑运算符-和-与它们对应的位运算符-和-的第二个重要的区别就是，如果对第一个参数求值就能确定表达式的结果，那么逻辑运算不会继续对第二个数求值-短路特性"><a href="#逻辑运算符-和-与它们对应的位运算符-和-的第二个重要的区别就是，如果对第一个参数求值就能确定表达式的结果，那么逻辑运算不会继续对第二个数求值-短路特性" class="headerlink" title="逻辑运算符&amp;&amp;和||与它们对应的位运算符&amp;和|的第二个重要的区别就是，如果对第一个参数求值就能确定表达式的结果，那么逻辑运算不会继续对第二个数求值(短路特性)"></a>逻辑运算符&amp;&amp;和||与它们对应的位运算符&amp;和|的第二个重要的区别就是，如果对第一个参数求值就能确定表达式的结果，那么逻辑运算不会继续对第二个数求值(短路特性)</h2><p> so,a&amp;&amp;5&#x2F;a不会造成被零除  p&amp;&amp;<em>p++也不会导致间接引用空指针(p是指针，</em>解引用)</p></li><li><h1 id="逻辑右移和算术右移"><a href="#逻辑右移和算术右移" class="headerlink" title="逻辑右移和算术右移"></a>逻辑右移和算术右移</h1></li></ol><p>算术右移要高位直接补1(适合有符号数) 对于无符号数，右移必须是逻辑的</p><ol><li><h1 id="无符号编码具有唯一性"><a href="#无符号编码具有唯一性" class="headerlink" title="无符号编码具有唯一性"></a>无符号编码具有唯一性</h1></li></ol><p>是一个双射  补码编码也具有唯一性</p><ol><li><h1 id="补码编码的另一种转成二进制的方法"><a href="#补码编码的另一种转成二进制的方法" class="headerlink" title="补码编码的另一种转成二进制的方法"></a>补码编码的另一种转成二进制的方法</h1></li></ol><p>比如1111 &#x3D; -1<em>2^3+1</em>2^2+1<em>2^1+1</em>2^0&#x3D;-1</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
